/**
 * @copyright Copyright (c) Open-Xchange GmbH, Germany <info@open-xchange.com>
 * @license AGPL-3.0
 *
 * This code is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with OX App Suite. If not, see <https://www.gnu.org/licenses/agpl-3.0.txt>.
 *
 * Any use of the work other than as authorized under this license or copyright law is prohibited.
 */const r=self.location.pathname.replace("/service-worker.js",""),L=`${r}/api`;let l;const i={async disable(){console.log("Service worker:","disable debug"),caches.open("debug").then(e=>e.delete("enabled"))},async enable(){console.log("Service worker:","enable debug"),(await caches.open("debug")).put("enabled",new Response)},trace(...e){caches.open("debug").then(async a=>{await a.match("enabled")&&console.log("Service worker:",...e)})},log(...e){caches.open("log").then(async a=>{const t=+new Date;a.put(t,new Response(JSON.stringify({timestamp:t,args:e}),{headers:{"content-type":"application/json"}}))}),i.trace(...e)},async printLogs(){const e=await caches.open("log"),a=await e.keys();for(const t of a){const n=await e.match(t),{timestamp:s,args:o}=await n.json();console.log(`[${new Date(s).toISOString()}]`,...o)}}};self.addEventListener("fetch",function(e){e.request.method!=="GET"||!e.request.url.startsWith(self.registration.scope)||new URL(e.request.url).pathname.startsWith(L)||e.request.headers?.get("service-worker-strategy")==="network-only"||e.respondWith(A(e.request,e.clientId))});self.addEventListener("activate",function(e){i.log("activate event"),e.waitUntil(self.clients.claim())});self.addEventListener("install",e=>{i.log("install event"),self.skipWaiting(),e.waitUntil(y(`${r}/`))});async function w(e,a){const t=await m(e,a);if(t){const n=t.headers.get("version");v({type:"NEW_VERSION",origin:"pollVersion",version:n}),d({response:a,url:e.url||e,version:n})}}self.addEventListener("message",e=>{e?.data==="POLL"&&w(`${r}/`),e?.data==="ENABLE_DEBUG"&&i.enable(),e?.data==="DISABLE_DEBUG"&&i.disable(),e?.data==="PRINT_LOGS"&&i.printLogs(),e?.data?.type==="INVALIDATE_CACHE"&&R(e.data.fileNames)});self.addEventListener("periodicsync",e=>{e.tag==="POLL"&&w(`${r}/`)});async function v(e){(await self.clients.matchAll()).forEach(t=>t.postMessage(e))}async function y(e,a){const t=await m(e,a);if(t){await k();const n=await caches.open("defaultcache");l=t.headers.get("version"),await Promise.all([n.put("/version",t.clone()),d({response:a,url:e.url||e,version:l})])}}async function m(e,a){i.trace("poll version");const t=await caches.open("defaultcache"),[n,s]=await Promise.all([t.match("/version"),a||fetch(e)]);if(s.ok){if(!n){t.put("/version",s.clone());return}if(s.headers.get("version")&&n.headers.get("version")!==s.headers.get("version"))return i.log("new version",s.headers.get("version"),"is navigational",e.mode==="navigate"),s}}async function R(e){const a=await E();await Promise.all(e.map(async t=>(await caches.open(a+b(t))).delete(t)))}async function k(){i.log("delete caches");const e=await this.caches.keys();await Promise.all(e.map(a=>a==="log"||a==="versionLog"?caches.open(a).then(async t=>{const n=await t.keys(),s=n.slice(0,n.length-150);return Promise.all(s.map(o=>t.delete(o)))}):caches.delete(a)))}async function g(e,a){return fetch(e,{headers:a}).catch(t=>(i.log(`Caught error while fetching ${e.url||e}`,t),new Response("",{status:503})))}async function p(e,a,{waitIntervals:t=[1e3,5e3,1e4]}={}){let n=await g(e,a);for(let s=0;s<t.length&&n.status===503;s++)i.log(`Received 503 for ${e.url||e}. Will retry`),await new Promise(o=>setTimeout(o,t[s])),n=await g(e,a);return n}function b(e){const a=e.substring(r.length).match(/^((\/[^/]+){0,2}).*\/[^/]+$/);return a?a[1]:""}async function A(e,a){const t=e.url,n=new URL(t).pathname;if(e.mode==="navigate"){i.trace("navigational request",n);const u=await p(e);return await y(e,u),u}const s=await E(),o=await caches.open(s+b(n)),f=await o.match(e);if(f)return f;const c=await p(e,{version:s});if(c.status!==200)return i.log("cannot fetch",t,"code",c.status),c;const h=c.headers.get("latest-version")||c.headers.get("version");return s&&h&&s!==h&&(v({type:"NEW_VERSION",origin:"fetchFile",status:c.status,version:h,url:t}),d({response:c,url:t})),o.put(t,c.clone()),c}async function d({response:e,url:a,version:t=e?.headers?.get("latest-version")||e.headers.get("version")}){if(!t)return;const n=await caches.open("versionLog");await n.match(t)||(n.put(t,new Response(a,{headers:e?.headers})),i.log(`New Version event triggered by ${a}`))}async function E(){return l||(l=(async()=>{const e=await caches.open("defaultcache");let a=await e.match("/version");return a||(i.log("defaultcache has no /version"),a=await fetch(`${r}/`).then(t=>{if(t.headers.get("version"))return e.put("/version",t),t}),i.log("server version is",a.headers.get("version"))),a.headers.get("version")})()),l}
//# sourceMappingURL=service-worker.js.map
