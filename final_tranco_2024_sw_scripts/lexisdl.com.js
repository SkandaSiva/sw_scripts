class e{constructor(e="keyval-store",t="keyval",r=1,s){this.storeName=t,this._dbp=new Promise(((n,a)=>{const o=indexedDB.open(e,r);o.onerror=()=>a(o.error),o.onsuccess=()=>n(o.result),o.onupgradeneeded=e=>{let r;r=o.result.objectStoreNames.contains(t)?o.transaction.objectStore(t):o.result.createObjectStore(t),s&&s(r,e.oldVersion)}}))}_withIDBStore(e,t){return this._dbp.then((r=>new Promise(((s,n)=>{const a=r.transaction(this.storeName,e);a.oncomplete=e=>s(e),a.onabort=a.onerror=()=>n(a.error),t(a.objectStore(this.storeName))}))))}}let t;function r(){return t||(t=new e),t}class s{static get(e,t=r()){let s;return t._withIDBStore("readonly",(t=>{s=t.get(e)})).then((()=>s.result))}static set(e,t,s=r()){return s._withIDBStore("readwrite",(r=>{r.put(t,e)}))}static del(e,t=r()){return t._withIDBStore("readwrite",(t=>{t.delete(e)}))}static clear(e=r()){return e._withIDBStore("readwrite",(e=>{e.clear()}))}static keys(e=r()){const t=[];return e._withIDBStore("readonly",(e=>{(e.openKeyCursor||e.openCursor).call(e).onsuccess=function(){this.result&&(t.push(this.result.key),this.result.continue())}})).then((()=>t))}static getAllByIndex(e,t,s=r()){let n=[];return s._withIDBStore("readonly",(r=>{let s=r.index(e),a=IDBKeyRange.only(t);return s.openCursor(a).onsuccess=function(e){let t=e.target.result;if(!t)return this.transaction.oncomplete(n);n.push({key:t.primaryKey,value:t.value}),t.continue()}}))}static getAllKeysByIndex(e,t,s=r()){let n=[];return s._withIDBStore("readonly",(r=>{let s=r.index(e),a=IDBKeyRange.only(t);return s.openCursor(a).onsuccess=function(e){let t=e.target.result;if(!t)return this.transaction.oncomplete(n);n.push(t.primaryKey),t.continue()}}))}}class n extends s{static get(e){return super.get(e,this._getStore())}static set(e,t){return super.set(e,t,this._getStore())}static del(e){return super.del(e,this._getStore())}static clear(){return super.clear(this._getStore())}static keys(){return super.keys(this._getStore())}static getAllByIndex(e,t){return super.getAllByIndex(e,t,this._getStore())}static _getStore(){if(!this._dbSettings)throw"Invalid DB configuration";return this._store||(this._store=new e(this._dbSettings.name,this._dbSettings.store,this._dbSettings.version,this._dbSettings.onUpgrade)),this._store}}class a extends n{static getRosterIdsByHealth(e){return super.getAllKeysByIndex("health",e,this._getStore())}}a._dbSettings={name:"nautilus-rosters",store:"nautilus-rosters",version:2,onUpgrade:(e,t)=>{if(t<2){if(1===t)try{e.deleteIndex("cache-roster-entry")}catch(e){}e.createIndex("health","health",{multiEntry:!0})}}};class o extends n{}o._dbSettings={name:"nautilus-data",store:"nautilus-data",version:1};class i{constructor(){this._algo="AES-GCM"}async encrypt(e,t){const r=await this._getKey();return crypto.subtle.encrypt({name:this._algo,iv:t},r,e)}async decrypt(e,t){const r=await this._getKey();return crypto.subtle.decrypt({name:this._algo,iv:t},r,e)}stringToIv(e){return e=e.padEnd(12),(new TextEncoder).encode(e).reverse().slice(0,11)}async _getKey(){return this._key||(this._key=await o.get("crypt-key"),this._key||(this._key=await crypto.subtle.generateKey({name:this._algo,length:256},!1,["encrypt","decrypt"]),await o.set("crypt-key",this._key))),this._key}}class c{constructor(){this._proxyMap={},this._cryptKeeper=new i}async get(e){const t=e.request,r=new URL(t.url);console.debug(`[FETCH] requesting: ${t.url}`),"/config"!==r.pathname&&(r.origin===self.location.origin?t.headers&&t.headers.has("X-Dervish-Prefetch")?console.debug("[FETCH] bypassing cache for prefetch request"):r.searchParams.get("channel")||e.respondWith(this._handleRequest(t,e.clientId)):console.debug(`[FETCH] cross domain -> network: ${t.url}`))}async _handleRequest(e,t){let r=!1;try{const s=await this._deproxifyUrl(e,t);return console.debug(`[FETCH] After deproxify, url: ${s.request.url}, was: ${e.url}`),r=s.deproxified,await this._cacheThenNetwork(s)}catch(t){if(console.error("[FETCH] Error processing fetch: %O -- Deproxified?: %s",t,r),t instanceof u)return new Response("Error deproxyfying request for ID: "+t.proxyId,{status:404});if(r||"Failed to fetch"===t.message||"NetworkError when attempting to fetch resource."===t.message)throw t;return fetch(e)}}clearInvalidRosters(){this._invalidRosterIds=null}async _getProxyRoot(e){let t=this._proxyMap[e];if(t)return t;let r=await o.get(e);if(r&&(t=r.root,this._proxyMap[e]=t),!t)throw new Error("Unable to map proxy ID to entry");return t}async _deproxifyUrl(e,t){let r,s=new RegExp(/_proxy-(\w+)(\/.*)/);if(r=e.url.match(s))try{console.debug(`[FETCH] requestMatch - proxy id: ${r[1]}`);const t=await this._getProxyRoot(r[1])+r[2].substr(1);return console.debug(`[FETCH] requestMatch - proxy - updatedUrl: ${t}`),{request:await this._transformRequest(e,t),deproxified:!0,ambiguousUrl:!1}}catch(e){throw console.warn(`[FETCH] Failed to find proxy entry: ${r[1]} -- exception: ${e}`),new u(r[1])}else{const n=await self.clients.get(t);if(n&&n.url&&(r=n.url.match(s))||e.referrer&&(r=e.referrer.match(s)))try{console.debug(`[FETCH] referrerMatch - proxy id: ${r[1]}`);const t=new URL(e.url),s=await this._getProxyRoot(r[1]);return t.hostname=new URL(s).hostname,{request:await this._transformRequest(e,t.href),deproxified:!0,ambiguousUrl:!0}}catch(e){throw console.warn(`[FETCH] Failed to find proxy entry: ${r[1]} -- exception: ${e}`),new u(r[1])}}return{request:e,deproxified:!1,ambiguousUrl:!1}}async _transformRequest(e,t){const r=this._whitelistHeaders(e.headers);let s;return e.headers.get("Content-Type")&&(s=await e.blob()),new Request(t,{headers:r,method:e.method,referrer:e.referrer,referrerPolicy:e.referrerPolicy,body:s,credentials:"include",cache:e.cache,redirect:e.redirect,integrity:e.integrity})}_whitelistHeaders(e){const t=new Headers;return e.forEach(((e,r)=>{c.REQUEST_HEADER_WHITELIST.includes(r)&&t.append(r,e)})),t}async _cacheThenNetwork(e){try{let t=await this._retrieveFromCache(e.request);if(!t&&"navigate"===e.request.mode&&!e.deproxified){const r=new URL(e.request.url);r.pathname.length>1&&!r.pathname.startsWith("/api")&&!r.pathname.match(/\.(x?html?|css|js|map)$/)&&(console.debug(`[FETCH] Cache miss on: ${e.request.url} -- now try root URL`),t=await this._retrieveFromCache(new Request(r.origin)))}if(t)return t;console.debug(`[FETCH] Cache missed, going to network for: ${e.request.url}`)}catch(t){console.error("[FETCH] Error processing request: %s -- ex: %O",e.request.url,t)}if(e.deproxified){console.debug(`[FETCH] Cache miss for ${e.request.url} -- assuming Dervish b/c request was deproxified`);if(new URL(e.request.url).pathname.includes("/_d/cover/"))return fetch(e.request.url);e.request.headers.delete("range"),e.request.headers.append("X-Dervish-Prefetch","V13;manualRedirect");const t=await fetch(e.request);if(204===t.status&&t.headers.has("X-Dervish-Redirect")){const r=t.headers.get("X-Dervish-Redirect");return console.debug(`[FETCH] Dervish redirect from: ${e.request.url} -> ${r}`),fetch(r)}if(e.ambiguousUrl){const e=new Headers(t.headers);return e.set("Cache-Control","no-store, max-age=0"),new Response(this._isNullBodyStatus(t.status)?null:t.body,{headers:e,status:t.status,statusText:t.statusText})}return t}return fetch(e.request)}async _retrieveFromCache(e){const t=await this._getInvalidRosterIds(),r=await caches.keys();for(let s=0;s<r.length;s++)if(!t.includes(r[s])){const t=await caches.open(r[s]);let n,a=await t.match(e.url);if(a||(n=new URL(new URL(e.url).pathname,"https://nautilus-browser.overdrive.com").toString(),a=await t.match(n)),a){console.debug(`[FETCH] Found cache entry for ${e.url} in ${r[s]}`);const t=await a.arrayBuffer(),o=await this._cryptKeeper.decrypt(t,this._cryptKeeper.stringToIv(n||e.url)),i=a.headers;i.get("content-length")||i.set("Content-Length",o.byteLength.toString()),"audio/mpeg"===i.get("content-type")&&i.set("Accept-Ranges","bytes"),i.set("Cache-Control","no-store, max-age=0");const c=new Response(o,{headers:a.headers,status:a.status,statusText:a.statusText});return this._isValidRangeRequest(e,c)?this._handleRangeRequest(e,c):c}}}async _handleRangeRequest(e,t){const r=await t.arrayBuffer();try{const s=this._parseRange(e.headers.get("Range"),r.byteLength),n=r.slice(s.start,s.end),a=new Response(n,{status:206,statusText:"Partial Content",headers:t.headers});return a.headers.set("Content-Length",`${n.byteLength}`),a.headers.set("Content-Range",`bytes ${s.start}-${s.end-1}/${r.byteLength}`),a}catch(t){const r=t.message.split(":");return console.warn(`[FETCH] Invalid range request for ${e.url}. Status: ${r[0]} ${r[1]}`),new Response(r[1],{status:Number(r[0])})}}_isValidRangeRequest(e,t){return!!e.headers.get("Range")&&200===t.status}_parseRange(e,t){if(!e.startsWith("bytes="))throw new Error("400:Invalid range unit");const r=/^bytes\=(\d*)\-(\d*)$/g.exec(e);if(!r[1]&&!r[2])throw new Error("400:Invalid range header");const s={start:Number(r[1]),end:t};if(""===r[1]?s.start=t-Number(r[2]):""!==r[2]&&(s.end=Number(r[2])+1),console.debug("[FETCH] range request - header: %s -- range: %O",e,s),s.start<0||s.end>t)throw new Error("416:Range Not Satisfiable");return s}async _getInvalidRosterIds(){return this._invalidRosterIds||(this._invalidRosterIds=await a.getRosterIdsByHealth("invalid")),this._invalidRosterIds}_isNullBodyStatus(e){return[101,204,205,304].includes(e)}}c.REQUEST_HEADER_WHITELIST=["accept","accept-language","content-language","content-type","range","x-dervish-prefetch","x-dervish-decree"];class u extends Error{constructor(e){super("Unable to deproxify request"),this.name="DeproxifyError",this.proxyId=e}}console.log("[NAUTILUS-SW] Starting up..."),self.addEventListener("install",(e=>{console.log("[NAUTILUS-SW] Installing..."),self.skipWaiting(),e.waitUntil(async function(){let e=await a.keys(),t=await caches.keys();for(let r of t)-1===e.indexOf(r)&&await caches.delete(r)}())})),self.addEventListener("activate",(e=>{console.log("[NAUTILUS-SW] Activating..."),e.waitUntil(self.clients.claim())}));let l=new c;self.addEventListener("fetch",(e=>{l.get(e)})),self.addEventListener("message",(e=>{"invalid-roster-update"===e.data.name&&l.clearInvalidRosters()}));
//# sourceMappingURL=nautilus-sw.js.map
