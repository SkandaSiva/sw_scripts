"use strict";(()=>{var $="DashSW:v2",l="sw-expire-ms",I=36e5,X=6048e5,j=864e5;function n(e){console.debug(`${new Date().toISOString()}: sw: ${e}`)}var b="DashSW",p="KeyValue";function u(e){return new Promise((t,s)=>{e.onsuccess=()=>t(e.result),e.onerror=()=>s(e.error)})}var f;function m(){if(!f){let e=indexedDB.open(b);e.onupgradeneeded=()=>e.result.createObjectStore(p),f=u(e)}return f}async function _(e){return(await m()).transaction(p,e).objectStore(p)}async function y(e){let t=await _("readonly");return await u(t.get(e))}async function g(e,t){let s=await _("readwrite");await u(s.put(t,e))}var x="lastGcMs",h=0;async function D(){return h||(h=await y(x))}async function C(e){h=e,await g(x,e)}async function k(){let e=await _("readwrite");await u(e.clear()),h=0}async function L(e,t,s,o){if(s.status!==200&&s.status!==301)return;let c=Date.now(),a=c+o,i=s.headers.get("date");if(i){let d=new Date(i),M=d.getTime();if(M<c&&(a=M+o,c>=a)){console.debug(`sw.js: Skipping cachePut for ${t.url} as it is already expired by response date: responseDate=${d}, now=${new Date(c)}, expiry=${new Date(a)}, maxAgeMs=${o}`);return}}let r=s.clone(),w=new Headers(r.headers);w.append(l,String(a));let S=await r.blob();try{let d=new Response(S,{status:r.status,statusText:r.statusText,headers:w});e.put(t,d)}catch(d){console.debug(`sw.js: Cannot cache ${t.url}`,d)}}function E(e,t){let s=t.headers.get(l),o=Date.now();return s?Number(s)<o?(n(`cached entry expired: expireMs=${s}, now=${o}, url=${e}`),!0):(n(`cached entry unexpired: expireMs=${s}, now=${o}, url=${e}`),!1):(n(`cached entry has no ${l} header, url=${e}`),!0)}function A(e,t=location.origin){return e.startsWith("https://assets.dropbox.com/")?(n(`should cache ${e} for 604800000ms - AEM asset`),6048e5):e.startsWith(t+"/sw.js")?(n(`should not cache ${e} - SW`),0):e.startsWith(t)?e.includes("?")?(n(`should not cache ${e} - has query params`),0):e.endsWith(".js")&&t==="http://localhost:3000"?(n(`should not cache ${e} - is localhost js`),0):e.startsWith(`${t}/static/`)?(n(`should cache ${e} for 604800000ms - static asset`),6048e5):e.endsWith(".ico")?(n(`should cache ${e} for 604800000ms - .ico`),6048e5):e.endsWith(".txt")?(n(`should cache ${e} for 604800000ms - .txt`),6048e5):(n(`should cache ${e} for 3600000ms - default or index.html`),36e5):(n(`should not cache ${e} - different origin`),0)}async function O(e,t){t?.catch(()=>{});let s=e.url??"",o=A(s);if(!o)return await fetch(e);let c=await caches.open($),a=await c.match(e);return a&&E(s,a)&&(n(`cache expired for ${s}`),c.delete(e),a=void 0),a?(n(`cache hit for ${s}`),a):(a=await fetch(e),a?(n(`add fetch ${s} to cache`),L(c,e,a,o)):n(`fetch ${s} but response is ${a}`),a)}async function G(){let e=await D();if(e){let t=Date.now()-e;if(t<864e5){n(`no need GC - elapsed=${t} ms, lastGcMs=${e}`);return}}C(Date.now()),await v()}async function v(){let e=Date.now();n(`start GC - ${e}`);let t=await caches.keys();for(let o of t){if(o!==$){n(`GC - delete old cache ${o}`),await caches.delete(o);continue}let c=await caches.open(o),a=await c.keys();for(let i of a){let r=await c.match(i);r&&E(i.url,r)&&(n(`GC - delete expired entry ${i.url}`),c.delete(i))}}let s=Date.now()-e;n(`end GC - took ${s} ms`)}function P(e,t){n("install"),e.skipWaiting()}function R(e,t){n("activate"),t.waitUntil(N(e))}async function N(e){await G(),await e.registration?.navigationPreload.disable()}function T(e){n(`fetch ${e.request.url}`),A(e.request.url)&&e.respondWith(W(e))}async function W(e){return await G(),await O(e.request,e.preloadResponse)}self.addEventListener("install",e=>{P(self,e)});self.addEventListener("activate",e=>{R(self,e)});self.addEventListener("fetch",e=>{T(e)});})();
