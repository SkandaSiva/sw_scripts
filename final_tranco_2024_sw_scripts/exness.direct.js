(()=>{"use strict";var e={794:()=>{try{self["workbox:core:6.5.3"]&&_()}catch(e){}},307:()=>{try{self["workbox:precaching:6.5.3"]&&_()}catch(e){}},745:()=>{try{self["workbox:routing:6.5.3"]&&_()}catch(e){}},825:()=>{try{self["workbox:strategies:6.5.3"]&&_()}catch(e){}}},t={};function __webpack_require__(r){var s=t[r];if(void 0!==s)return s.exports;var a=t[r]={exports:{}};return e[r](a,a.exports,__webpack_require__),a.exports}(()=>{__webpack_require__(794);const messageGenerator=function(e){let t=e;for(var r=arguments.length,s=new Array(r>1?r-1:0),a=1;a<r;a++)s[a-1]=arguments[a];return s.length>0&&(t+=` :: ${JSON.stringify(s)}`),t};class WorkboxError_WorkboxError extends Error{constructor(e,t){super(messageGenerator(e,t)),this.name=e,this.details=t}}__webpack_require__(745);const normalizeHandler=e=>e&&"object"===typeof e?e:{handle:e};class Route{constructor(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"GET";this.handler=normalizeHandler(t),this.match=e,this.method=r}setCatchHandler(e){this.catchHandler=normalizeHandler(e)}}class RegExpRoute extends Route{constructor(e,t,r){super((t=>{let{url:r}=t;const s=e.exec(r.href);if(s&&(r.origin===location.origin||0===s.index))return s.slice(1)}),t,r)}}const getFriendlyURL=e=>new URL(String(e),location.href).href.replace(new RegExp(`^${location.origin}`),"");class Router{constructor(){this._routes=new Map,this._defaultHandlerMap=new Map}get routes(){return this._routes}addFetchListener(){self.addEventListener("fetch",(e=>{const{request:t}=e,r=this.handleRequest({request:t,event:e});r&&e.respondWith(r)}))}addCacheListener(){self.addEventListener("message",(e=>{if(e.data&&"CACHE_URLS"===e.data.type){const{payload:t}=e.data;0;const r=Promise.all(t.urlsToCache.map((t=>{"string"===typeof t&&(t=[t]);const r=new Request(...t);return this.handleRequest({request:r,event:e})})));e.waitUntil(r),e.ports&&e.ports[0]&&r.then((()=>e.ports[0].postMessage(!0)))}}))}handleRequest(e){let{request:t,event:r}=e;const s=new URL(t.url,location.href);if(!s.protocol.startsWith("http"))return void 0;const a=s.origin===location.origin,{params:o,route:n}=this.findMatchingRoute({event:r,request:t,sameOrigin:a,url:s});let i=n&&n.handler;const c=t.method;if(!i&&this._defaultHandlerMap.has(c)&&(i=this._defaultHandlerMap.get(c)),!i)return void 0;let l;try{l=i.handle({url:s,request:t,event:r,params:o})}catch(u){l=Promise.reject(u)}const h=n&&n.catchHandler;return l instanceof Promise&&(this._catchHandler||h)&&(l=l.catch((async e=>{if(h){0;try{return await h.handle({url:s,request:t,event:r,params:o})}catch(a){a instanceof Error&&(e=a)}}if(this._catchHandler)return this._catchHandler.handle({url:s,request:t,event:r});throw e}))),l}findMatchingRoute(e){let{url:t,sameOrigin:r,request:s,event:a}=e;const o=this._routes.get(s.method)||[];for(const n of o){let e;const o=n.match({url:t,sameOrigin:r,request:s,event:a});if(o)return e=o,(Array.isArray(e)&&0===e.length||o.constructor===Object&&0===Object.keys(o).length||"boolean"===typeof o)&&(e=void 0),{route:n,params:e}}return{}}setDefaultHandler(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"GET";this._defaultHandlerMap.set(t,normalizeHandler(e))}setCatchHandler(e){this._catchHandler=normalizeHandler(e)}registerRoute(e){this._routes.has(e.method)||this._routes.set(e.method,[]),this._routes.get(e.method).push(e)}unregisterRoute(e){if(!this._routes.has(e.method))throw new WorkboxError_WorkboxError("unregister-route-but-not-found-with-method",{method:e.method});const t=this._routes.get(e.method).indexOf(e);if(!(t>-1))throw new WorkboxError_WorkboxError("unregister-route-route-not-registered");this._routes.get(e.method).splice(t,1)}}let e;const getOrCreateDefaultRouter_getOrCreateDefaultRouter=()=>(e||(e=new Router,e.addFetchListener(),e.addCacheListener()),e);function registerRoute(e,t,r){let s;if("string"===typeof e){const a=new URL(e,location.href);0;s=new Route((e=>{let{url:t}=e;return t.href===a.href}),t,r)}else if(e instanceof RegExp)s=new RegExpRoute(e,t,r);else if("function"===typeof e)s=new Route(e,t,r);else{if(!(e instanceof Route))throw new WorkboxError_WorkboxError("unsupported-route-type",{moduleName:"workbox-routing",funcName:"registerRoute",paramName:"capture"});s=e}return getOrCreateDefaultRouter_getOrCreateDefaultRouter().registerRoute(s),s}const t={googleAnalytics:"googleAnalytics",precache:"precache-v2",prefix:"workbox",runtime:"runtime",suffix:"undefined"!==typeof registration?registration.scope:""},_createCacheName=e=>[t.prefix,e,t.suffix].filter((e=>e&&e.length>0)).join("-"),cacheNames_cacheNames_getGoogleAnalyticsName=e=>e||_createCacheName(t.googleAnalytics),cacheNames_cacheNames_getPrecacheName=e=>e||_createCacheName(t.precache),cacheNames_cacheNames_getPrefix=()=>t.prefix,cacheNames_cacheNames_getRuntimeName=e=>e||_createCacheName(t.runtime),cacheNames_cacheNames_getSuffix=()=>t.suffix;function waitUntil(e,t){const r=t();return e.waitUntil(r),r}__webpack_require__(307);const r="__WB_REVISION__";function createCacheKey(e){if(!e)throw new WorkboxError_WorkboxError("add-to-cache-list-unexpected-type",{entry:e});if("string"===typeof e){const t=new URL(e,location.href);return{cacheKey:t.href,url:t.href}}const{revision:t,url:s}=e;if(!s)throw new WorkboxError_WorkboxError("add-to-cache-list-unexpected-type",{entry:e});if(!t){const e=new URL(s,location.href);return{cacheKey:e.href,url:e.href}}const a=new URL(s,location.href),o=new URL(s,location.href);return a.searchParams.set(r,t),{cacheKey:a.href,url:o.href}}class PrecacheInstallReportPlugin{constructor(){this.updatedURLs=[],this.notUpdatedURLs=[],this.handlerWillStart=async e=>{let{request:t,state:r}=e;r&&(r.originalRequest=t)},this.cachedResponseWillBeUsed=async e=>{let{event:t,state:r,cachedResponse:s}=e;if("install"===t.type&&r&&r.originalRequest&&r.originalRequest instanceof Request){const e=r.originalRequest.url;s?this.notUpdatedURLs.push(e):this.updatedURLs.push(e)}return s}}}class PrecacheCacheKeyPlugin{constructor(e){let{precacheController:t}=e;this.cacheKeyWillBeUsed=async e=>{let{request:t,params:r}=e;const s=(null===r||void 0===r?void 0:r.cacheKey)||this._precacheController.getCacheKeyForURL(t.url);return s?new Request(s,{headers:t.headers}):t},this._precacheController=t}}let s;async function copyResponse(e,t){let r=null;if(e.url){r=new URL(e.url).origin}if(r!==self.location.origin)throw new WorkboxError_WorkboxError("cross-origin-copy-response",{origin:r});const a=e.clone(),o={headers:new Headers(a.headers),status:a.status,statusText:a.statusText},n=t?t(o):o,i=function canConstructResponseFromBodyStream(){if(void 0===s){const t=new Response("");if("body"in t)try{new Response(t.body),s=!0}catch(e){s=!1}s=!1}return s}()?a.body:await a.blob();return new Response(i,n)}function stripParams(e,t){const r=new URL(e);for(const s of t)r.searchParams.delete(s);return r.href}class Deferred{constructor(){this.promise=new Promise(((e,t)=>{this.resolve=e,this.reject=t}))}}const a=new Set;__webpack_require__(825);function toRequest(e){return"string"===typeof e?new Request(e):e}class StrategyHandler{constructor(e,t){this._cacheKeys={},Object.assign(this,t),this.event=t.event,this._strategy=e,this._handlerDeferred=new Deferred,this._extendLifetimePromises=[],this._plugins=[...e.plugins],this._pluginStateMap=new Map;for(const r of this._plugins)this._pluginStateMap.set(r,{});this.event.waitUntil(this._handlerDeferred.promise)}async fetch(e){const{event:t}=this;let r=toRequest(e);if("navigate"===r.mode&&t instanceof FetchEvent&&t.preloadResponse){const e=await t.preloadResponse;if(e)return e}const s=this.hasCallback("fetchDidFail")?r.clone():null;try{for(const e of this.iterateCallbacks("requestWillFetch"))r=await e({request:r.clone(),event:t})}catch(o){if(o instanceof Error)throw new WorkboxError_WorkboxError("plugin-error-request-will-fetch",{thrownErrorMessage:o.message})}const a=r.clone();try{let e;e=await fetch(r,"navigate"===r.mode?void 0:this._strategy.fetchOptions);for(const r of this.iterateCallbacks("fetchDidSucceed"))e=await r({event:t,request:a,response:e});return e}catch(n){throw s&&await this.runCallbacks("fetchDidFail",{error:n,event:t,originalRequest:s.clone(),request:a.clone()}),n}}async fetchAndCachePut(e){const t=await this.fetch(e),r=t.clone();return this.waitUntil(this.cachePut(e,r)),t}async cacheMatch(e){const t=toRequest(e);let r;const{cacheName:s,matchOptions:a}=this._strategy,o=await this.getCacheKey(t,"read"),n=Object.assign(Object.assign({},a),{cacheName:s});r=await caches.match(o,n);for(const i of this.iterateCallbacks("cachedResponseWillBeUsed"))r=await i({cacheName:s,matchOptions:a,cachedResponse:r,request:o,event:this.event})||void 0;return r}async cachePut(e,t){const r=toRequest(e);await function timeout_timeout(e){return new Promise((t=>setTimeout(t,e)))}(0);const s=await this.getCacheKey(r,"write");if(!t)throw new WorkboxError_WorkboxError("cache-put-with-no-response",{url:getFriendlyURL(s.url)});const o=await this._ensureResponseSafeToCache(t);if(!o)return!1;const{cacheName:n,matchOptions:i}=this._strategy,c=await self.caches.open(n),l=this.hasCallback("cacheDidUpdate"),h=l?await async function cacheMatchIgnoreParams(e,t,r,s){const a=stripParams(t.url,r);if(t.url===a)return e.match(t,s);const o=Object.assign(Object.assign({},s),{ignoreSearch:!0}),n=await e.keys(t,o);for(const i of n)if(a===stripParams(i.url,r))return e.match(i,s)}(c,s.clone(),["__WB_REVISION__"],i):null;try{await c.put(s,l?o.clone():o)}catch(u){if(u instanceof Error)throw"QuotaExceededError"===u.name&&await async function executeQuotaErrorCallbacks(){for(const e of a)await e()}(),u}for(const a of this.iterateCallbacks("cacheDidUpdate"))await a({cacheName:n,oldResponse:h,newResponse:o.clone(),request:s,event:this.event});return!0}async getCacheKey(e,t){const r=`${e.url} | ${t}`;if(!this._cacheKeys[r]){let s=e;for(const e of this.iterateCallbacks("cacheKeyWillBeUsed"))s=toRequest(await e({mode:t,request:s,event:this.event,params:this.params}));this._cacheKeys[r]=s}return this._cacheKeys[r]}hasCallback(e){for(const t of this._strategy.plugins)if(e in t)return!0;return!1}async runCallbacks(e,t){for(const r of this.iterateCallbacks(e))await r(t)}*iterateCallbacks(e){for(const t of this._strategy.plugins)if("function"===typeof t[e]){const r=this._pluginStateMap.get(t),statefulCallback=s=>{const a=Object.assign(Object.assign({},s),{state:r});return t[e](a)};yield statefulCallback}}waitUntil(e){return this._extendLifetimePromises.push(e),e}async doneWaiting(){let e;for(;e=this._extendLifetimePromises.shift();)await e}destroy(){this._handlerDeferred.resolve(null)}async _ensureResponseSafeToCache(e){let t=e,r=!1;for(const s of this.iterateCallbacks("cacheWillUpdate"))if(t=await s({request:this.request,response:t,event:this.event})||void 0,r=!0,!t)break;return r||t&&200!==t.status&&(t=void 0),t}}class Strategy_Strategy{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.cacheName=cacheNames_cacheNames_getRuntimeName(e.cacheName),this.plugins=e.plugins||[],this.fetchOptions=e.fetchOptions,this.matchOptions=e.matchOptions}handle(e){const[t]=this.handleAll(e);return t}handleAll(e){e instanceof FetchEvent&&(e={event:e,request:e.request});const t=e.event,r="string"===typeof e.request?new Request(e.request):e.request,s="params"in e?e.params:void 0,a=new StrategyHandler(this,{event:t,request:r,params:s}),o=this._getResponse(a,r,t);return[o,this._awaitComplete(o,a,r,t)]}async _getResponse(e,t,r){let s;await e.runCallbacks("handlerWillStart",{event:r,request:t});try{if(s=await this._handle(t,e),!s||"error"===s.type)throw new WorkboxError_WorkboxError("no-response",{url:t.url})}catch(a){if(a instanceof Error)for(const o of e.iterateCallbacks("handlerDidError"))if(s=await o({error:a,event:r,request:t}),s)break;if(!s)throw a}for(const o of e.iterateCallbacks("handlerWillRespond"))s=await o({event:r,request:t,response:s});return s}async _awaitComplete(e,t,r,s){let a,o;try{a=await e}catch(o){}try{await t.runCallbacks("handlerDidRespond",{event:s,request:r,response:a}),await t.doneWaiting()}catch(n){n instanceof Error&&(o=n)}if(await t.runCallbacks("handlerDidComplete",{event:s,request:r,response:a,error:o}),t.destroy(),o)throw o}}class PrecacheStrategy extends Strategy_Strategy{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};e.cacheName=cacheNames_cacheNames_getPrecacheName(e.cacheName),super(e),this._fallbackToNetwork=!1!==e.fallbackToNetwork,this.plugins.push(PrecacheStrategy.copyRedirectedCacheableResponsesPlugin)}async _handle(e,t){const r=await t.cacheMatch(e);return r||(t.event&&"install"===t.event.type?await this._handleInstall(e,t):await this._handleFetch(e,t))}async _handleFetch(e,t){let r;const s=t.params||{};if(!this._fallbackToNetwork)throw new WorkboxError_WorkboxError("missing-precache-entry",{cacheName:this.cacheName,url:e.url});{0;const a=s.integrity,o=e.integrity,n=!o||o===a;if(r=await t.fetch(new Request(e,{integrity:"no-cors"!==e.mode?o||a:void 0})),a&&n&&"no-cors"!==e.mode){this._useDefaultCacheabilityPluginIfNeeded();await t.cachePut(e,r.clone());0}}return r}async _handleInstall(e,t){this._useDefaultCacheabilityPluginIfNeeded();const r=await t.fetch(e);if(!await t.cachePut(e,r.clone()))throw new WorkboxError_WorkboxError("bad-precaching-response",{url:e.url,status:r.status});return r}_useDefaultCacheabilityPluginIfNeeded(){let e=null,t=0;for(const[r,s]of this.plugins.entries())s!==PrecacheStrategy.copyRedirectedCacheableResponsesPlugin&&(s===PrecacheStrategy.defaultPrecacheCacheabilityPlugin&&(e=r),s.cacheWillUpdate&&t++);0===t?this.plugins.push(PrecacheStrategy.defaultPrecacheCacheabilityPlugin):t>1&&null!==e&&this.plugins.splice(e,1)}}PrecacheStrategy.defaultPrecacheCacheabilityPlugin={async cacheWillUpdate(e){let{response:t}=e;return!t||t.status>=400?null:t}},PrecacheStrategy.copyRedirectedCacheableResponsesPlugin={async cacheWillUpdate(e){let{response:t}=e;return t.redirected?await copyResponse(t):t}};class PrecacheController{constructor(){let{cacheName:e,plugins:t=[],fallbackToNetwork:r=!0}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this._urlsToCacheKeys=new Map,this._urlsToCacheModes=new Map,this._cacheKeysToIntegrities=new Map,this._strategy=new PrecacheStrategy({cacheName:cacheNames_cacheNames_getPrecacheName(e),plugins:[...t,new PrecacheCacheKeyPlugin({precacheController:this})],fallbackToNetwork:r}),this.install=this.install.bind(this),this.activate=this.activate.bind(this)}get strategy(){return this._strategy}precache(e){this.addToCacheList(e),this._installAndActiveListenersAdded||(self.addEventListener("install",this.install),self.addEventListener("activate",this.activate),this._installAndActiveListenersAdded=!0)}addToCacheList(e){const t=[];for(const r of e){"string"===typeof r?t.push(r):r&&void 0===r.revision&&t.push(r.url);const{cacheKey:e,url:s}=createCacheKey(r),a="string"!==typeof r&&r.revision?"reload":"default";if(this._urlsToCacheKeys.has(s)&&this._urlsToCacheKeys.get(s)!==e)throw new WorkboxError_WorkboxError("add-to-cache-list-conflicting-entries",{firstEntry:this._urlsToCacheKeys.get(s),secondEntry:e});if("string"!==typeof r&&r.integrity){if(this._cacheKeysToIntegrities.has(e)&&this._cacheKeysToIntegrities.get(e)!==r.integrity)throw new WorkboxError_WorkboxError("add-to-cache-list-conflicting-integrities",{url:s});this._cacheKeysToIntegrities.set(e,r.integrity)}if(this._urlsToCacheKeys.set(s,e),this._urlsToCacheModes.set(s,a),t.length>0){const e=`Workbox is precaching URLs without revision info: ${t.join(", ")}\nThis is generally NOT safe. Learn more at https://bit.ly/wb-precache`;console.warn(e)}}}install(e){return waitUntil(e,(async()=>{const t=new PrecacheInstallReportPlugin;this.strategy.plugins.push(t);for(const[a,o]of this._urlsToCacheKeys){const t=this._cacheKeysToIntegrities.get(o),r=this._urlsToCacheModes.get(a),s=new Request(a,{integrity:t,cache:r,credentials:"same-origin"});await Promise.all(this.strategy.handleAll({params:{cacheKey:o},request:s,event:e}))}const{updatedURLs:r,notUpdatedURLs:s}=t;return{updatedURLs:r,notUpdatedURLs:s}}))}activate(e){return waitUntil(e,(async()=>{const e=await self.caches.open(this.strategy.cacheName),t=await e.keys(),r=new Set(this._urlsToCacheKeys.values()),s=[];for(const a of t)r.has(a.url)||(await e.delete(a),s.push(a.url));return{deletedURLs:s}}))}getURLsToCacheKeys(){return this._urlsToCacheKeys}getCachedURLs(){return[...this._urlsToCacheKeys.keys()]}getCacheKeyForURL(e){const t=new URL(e,location.href);return this._urlsToCacheKeys.get(t.href)}getIntegrityForCacheKey(e){return this._cacheKeysToIntegrities.get(e)}async matchPrecache(e){const t=e instanceof Request?e.url:e,r=this.getCacheKeyForURL(t);if(r){return(await self.caches.open(this.strategy.cacheName)).match(r)}}createHandlerBoundToURL(e){const t=this.getCacheKeyForURL(e);if(!t)throw new WorkboxError_WorkboxError("non-precached-url",{url:e});return r=>(r.request=new Request(e),r.params=Object.assign({cacheKey:t},r.params),this.strategy.handle(r))}}let o;const getOrCreatePrecacheController_getOrCreatePrecacheController=()=>(o||(o=new PrecacheController),o);class PrecacheRoute extends Route{constructor(e,t){super((r=>{let{request:s}=r;const a=e.getURLsToCacheKeys();for(const o of function generateURLVariations(e){let{ignoreURLParametersMatching:t=[/^utm_/,/^fbclid$/],directoryIndex:r="index.html",cleanURLs:s=!0,urlManipulation:a}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return function*(){const o=new URL(e,location.href);o.hash="",yield o.href;const n=function removeIgnoredSearchParams(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];for(const r of[...e.searchParams.keys()])t.some((e=>e.test(r)))&&e.searchParams.delete(r);return e}(o,t);if(yield n.href,r&&n.pathname.endsWith("/")){const e=new URL(n.href);e.pathname+=r,yield e.href}if(s){const e=new URL(n.href);e.pathname+=".html",yield e.href}if(a){const e=a({url:o});for(const t of e)yield t.href}}()}(s.url,t)){const t=a.get(o);if(t){return{cacheKey:t,integrity:e.getIntegrityForCacheKey(t)}}}}),e.strategy)}}const n={get googleAnalytics(){return cacheNames_cacheNames_getGoogleAnalyticsName()},get precache(){return cacheNames_cacheNames_getPrecacheName()},get prefix(){return cacheNames_cacheNames_getPrefix()},get runtime(){return cacheNames_cacheNames_getRuntimeName()},get suffix(){return cacheNames_cacheNames_getSuffix()}};const{REACT_APP_API_BASE_URL:i}={NODE_ENV:"production",PUBLIC_URL:"/pa",WDS_SOCKET_HOST:void 0,WDS_SOCKET_PATH:void 0,WDS_SOCKET_PORT:void 0,FAST_REFRESH:!0,REACT_APP_ROUTER_BASENAME:"/pa",REACT_APP_SENTRY_DSN:"https://0657fc27d0444b2baf05c7c3b31e7bc5@sentry2.exness.io/66",REACT_APP_SENTRY_TRACES_RATE:"0.2",REACT_APP_API_BASE_URL:"/v4/wta-api",REACT_APP_API_TAM_URL:"/v4/tam",REACT_APP_DEV_DOMAIN_ALIAS:"",REACT_APP_KYC_APP_URL:"/kyc/",REACT_APP_BOARDING_SURVEY_URL:"/kyc/onboarding-survey/",REACT_APP_WEBTRADING_URL:"/webtrading",REACT_APP_SUMSUB_PIXEL_URL:"https://api.sumsub.com/pixel.png",REACT_APP_MM_URL:"/pim/",REACT_APP_WL_CONFIG_URL:"",REACT_APP_DEBUG:"false",REACT_APP_PASSPORT_STAND:"/tcab/api/v1",REACT_APP_TELEGRAF_API_URL:"https://input.frontrics.site/telegraf",REACT_APP_TOTP_COUNTRIES:"ID,PK,NG,IN,BD,KH,LK,VN,CN,MA,DZ,KW,OM,EG,GH,ZA,NA,KE,CI,MV,BN",REACT_APP_ESLINT_NO_DEV_ERRORS:"true",BROWSER:!0,REACT_APP_CI_COMMIT_TAG:"undefined",REACT_APP_TAG:"2.6.61",REACT_APP_GIT_TAG:"2.6.61",REACT_APP_CI_COMMIT_REF_NAME:"develop"},c=`${i}/user/domain_info?types=partnership_pa%2Cpayments%2Ctrader_pa%2Cpublic_web_main`,l="https://ex-domains.web.app/domain",getUrlFromDMS=async()=>{try{const e=await caches.open(n.runtime),t=await e.match(c);if(t){console.log("Domains response is found in cache to get alternative");const{domains:e}=await t.json();return e.find((e=>"trader_pa"===e.type)).alternative}}catch(e){console.error("Did not manage to get an alternate domain from DMS",e)}},getUrlFromExSource=async e=>{try{return await fetch(e).then((e=>e.text()))}catch(t){console.error(`Did not manage to get an alternate domain from ex source: ${e}`,t)}},getAlternativeDomain=async e=>{var t;const[r,s]=await Promise.all([getUrlFromDMS(),getUrlFromExSource(e)]),a=r?new URL(`https://${r}`).origin:void 0;return null!==(t=null!==a&&void 0!==a?a:s)&&void 0!==t?t:void 0},isUrlReachable=async function(e,t){if(console.log(">>> :ExStrategy.js - checkUrl ...",e),!t)try{const t=await fetch(e,{mode:"no-cors"});return console.log(">>> :ExStrategy.js - checkUrl - RESULT: ",e,t),!0}catch(r){return console.log(">>> :ExStrategy.js - checkUrl - FAIL",e,r),!1}try{const r=await fetch(e).then((e=>e.text())),s=t(r);return console.log(">>> :ExStrategy.js - checkUrl (with contentChecker) - RESULT: ",{url:e,content:r,contentCheck:s}),s}catch(r){console.log(">>> :ExStrategy.js - checkUrl (with contentChecker) - FAIL",e,r)}return!1},checkDomainBan=async function(e,t){console.log(">>> :ExStrategy.js - checkDB: ",e);const r=e.host.startsWith("my.")||e.host.endsWith(".env")?`${e.origin}/pa/`:e.origin,s=await isUrlReachable(r,t);if(console.log(">>> :ExStrategy.js - checkDomainBan: isOK",s),s)return!1;const a=await isUrlReachable("https://worldtimeapi.org/api/timezone");return console.log(">>> :ExStrategy.js - checkDomainBan: isOnline",a),a};const h={cacheWillUpdate:async e=>{let{response:t}=e;return 200===t.status||0===t.status?t:null}};class NetworkFirst extends Strategy_Strategy{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(e),this.plugins.some((e=>"cacheWillUpdate"in e))||this.plugins.unshift(h),this._networkTimeoutSeconds=e.networkTimeoutSeconds||0}async _handle(e,t){const r=[];const s=[];let a;if(this._networkTimeoutSeconds){const{id:o,promise:n}=this._getTimeoutPromise({request:e,logs:r,handler:t});a=o,s.push(n)}const o=this._getNetworkPromise({timeoutId:a,request:e,logs:r,handler:t});s.push(o);const n=await t.waitUntil((async()=>await t.waitUntil(Promise.race(s))||await o)());if(!n)throw new WorkboxError_WorkboxError("no-response",{url:e.url});return n}_getTimeoutPromise(e){let t,{request:r,logs:s,handler:a}=e;return{promise:new Promise((e=>{t=setTimeout((async()=>{e(await a.cacheMatch(r))}),1e3*this._networkTimeoutSeconds)})),id:t}}async _getNetworkPromise(e){let t,r,{timeoutId:s,request:a,logs:o,handler:n}=e;try{r=await n.fetchAndCachePut(a)}catch(i){i instanceof Error&&(t=i)}return s&&clearTimeout(s),!t&&r||(r=await n.cacheMatch(a)),r}}const u="SERVICE_WORKER";let d,g=null;const sendMessage=function(e){g=e,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{}};const f=class ExStrategy extends NetworkFirst{constructor(e,t,r){let{redirectPage:s,errorPage:a,contentChecker:o,notifyAboutLongRequest:n=!1,defaultBehaviourWhenError:i=!1,domainSource:c="https://ex-domains.web.app/domain"}=r;super(t),this.swSelf=void 0,this.domainSource=void 0,this.errorPage=void 0,this.redirectPage=void 0,this.contentChecker=void 0,this.defaultBehaviourWhenError=void 0,this.notifyAboutLongRequest=void 0,this.domainSource=c,this.errorPage=a,this.redirectPage=s,this.notifyAboutLongRequest=n,this.swSelf=e,this.contentChecker=o,this.defaultBehaviourWhenError=i,this.subscribeToReadiness()}subscribeToReadiness(){this.swSelf.addEventListener("message",(e=>{console.log(">>> :ExStrategy.js - handle message: ",e);const{type:t,message:r}=e.data||{};t===u&&"ready"===r&&(async e=>{if(!g)return;const t=g,r=d;g=null,d=null;const s=await e.matchAll();for(const a of s)console.log(">>> :ExStrategy.js - postMessage to client: ",{client:a,msg:t,msgDetails:r}),a.postMessage({type:u,msg:t,details:r})})(this.swSelf.clients)}))}async _handle(e,t){console.log(">>> :ExStrategy.js - _handle ...",e.url);const r=new URL(e.url),s=(e=>{let{shouldMeasure:t}=e;if(!t)return()=>{};const r=setTimeout((async()=>{try{console.log(">>> :ExStrategy.js - notification about long operation is sent"),console.log(">>> :ExStrategy.js - successfully notified about long operation")}catch(e){console.log(">>> :ExStrategy.js - notification about long operation failed",{error:e})}}),2e4);return()=>clearTimeout(r)})({shouldMeasure:this.notifyAboutLongRequest}),a=await checkDomainBan(r,this.contentChecker);s();const o=a?await async function(e,t){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:l;try{const s=e.host.startsWith("localhost")?"localhost":e.host;console.log(">>> :ExStrategy.js - gND for: ",s);const a=await getAlternativeDomain(r);if(!a)return;const o=new URL(a);return await checkDomainBan(o,t)?a:void 0}catch(s){console.error(">>> ERROR:ExStrategy.js - gND: ",{url:e,err:s})}}(r,this.contentChecker,this.domainSource):void 0;console.log(">>> :ExStrategy.js - _handle: ",{isDB:a,newD:o}),a&&(void 0===o?sendMessage(2):sendMessage(1,{newDomain:o}));try{let r=null;return a&&(r=void 0===o?await this.getPageFromCache(this.errorPage,"error"):await this.getPageFromCache(this.redirectPage,"redirect")),console.log(">>> :ExStrategy.js - _handle: DONE ===============",r),null===r?await super._handle(e,t):r}catch(n){console.error(">>> :ExStrategy.js - _handle: SOMETHING WENT WRONG",n)}return this.handleAbnormalCase(e,t)}async getPageFromCache(e,t){console.log(`>>> :ExStrategy.js - try use ${t} page: `,{errorPage:e});try{const s=await caches.open(n.precache),a=await s.match(function getCacheKeyForURL(e){return getOrCreatePrecacheController_getOrCreatePrecacheController().getCacheKeyForURL(e)}(e));try{return a.clone()}catch(r){return console.log(`>>> :ExStrategy.js - Can not clone a matched cache for ${t} page: `,{url:e,e:r}),null}}catch(r){return console.log(`>>> :ExStrategy.js - Can not match a cache for ${t} page`,{url:e,e:r}),null}}async handleAbnormalCase(e,t){console.log(">>> :ExStrategy.js - handle abnormal case");try{return this.defaultBehaviourWhenError?await super._handle(e,t):await this.getPageFromCache(this.errorPage,"error")}catch(r){return console.error(">>> :ExStrategy.js - _handle: SOMETHING WENT WRONG 2",r),super._handle(e,t)}}},sw_waitUntilPolyfill=()=>{const e=ExtendableEvent.prototype.waitUntil,t=FetchEvent.prototype.respondWith,r=new WeakMap;ExtendableEvent.prototype.waitUntil=function(t){const s=this;let a=r.get(s);if(!a)return a=[Promise.resolve(t)],r.set(s,a),e.call(s,Promise.resolve().then((function processPromises(){const e=a.length;return Promise.all(a.map((e=>e.catch((()=>{}))))).then((()=>a.length!==e?processPromises():(r.delete(s),Promise.all(a))))})));a.push(Promise.resolve(t))},FetchEvent.prototype.respondWith=function(e){return this.waitUntil(e),t.call(this,e)}},validateContent=e=>/<meta[^>]+content="ZXRvbmFzaHNpdGVpbXllZ29ob3N0aW0="/.test(e);sw_waitUntilPolyfill(),self.skipWaiting(),function clientsClaim(){self.addEventListener("activate",(()=>self.clients.claim()))}();console.log(">>> :public-service-worker.js - VERSION: 1.2.4 (0.4.2)(15)");const p=[]||[];p.push({revision:15,url:"/cdn/media/sw/ab_error_public.html?v=15"}),p.push({revision:15,url:"/cdn/media/sw/ab_redirect_public.html?v=15"});const _=new f(self,{cacheName:"cached-navigations",plugins:[]},{domainSource:"https://ex-domains.web.app/pub_domain",errorPage:"/cdn/media/sw/ab_error_public.html",redirectPage:"/cdn/media/sw/ab_redirect_public.html",contentChecker:e=>{const t=validateContent(e);console.log(">>> :x-service-worker.js - c-Checker: ",t);const r=/<a[^>]+>Imperva<\/a>/.test(e);console.log(">>> :x-service-worker.js - c-Checker: is Imperva",r);const s=/<iframe.*?_Incapsula_Resource.*?<\/iframe>/.test(e);console.log(">>> :x-service-worker.js - c-Checker: is Incapsula",s);const a=/<script.*?src="(\/cdn-cgi\/challenge-platform\/.*?)"*<\/script>/.test(e);return console.log(">>> :x-service-worker.js - c-Checker: is Cloudflare",a),t||r||s||a},defaultBehaviourWhenError:!0});registerRoute(new class NavigationRoute extends Route{constructor(e){let{allowlist:t=[/./],denylist:r=[]}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super((e=>this._match(e)),e),this._allowlist=t,this._denylist=r}_match(e){let{url:t,request:r}=e;if(r&&"navigate"!==r.mode)return!1;const s=t.pathname+t.search;for(const a of this._denylist)if(a.test(s))return!1;return!!this._allowlist.some((e=>e.test(s)))}}(_)),console.log(">>> :public-service-worker.js - PRECACHE: ",p),function precacheAndRoute(e,t){!function precache(e){getOrCreatePrecacheController_getOrCreatePrecacheController().precache(e)}(e),function addRoute(e){const t=getOrCreatePrecacheController_getOrCreatePrecacheController();registerRoute(new PrecacheRoute(t,e))}(t)}(p)})()})();
//# sourceMappingURL=public-service-worker.js.map