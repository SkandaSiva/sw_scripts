const CACHE_VER="1";self.addEventListener("install",(e=>e.waitUntil(self.skipWaiting()))),self.addEventListener("activate",(e=>e.waitUntil(self.clients.claim())));const RPC={};self.addEventListener("message",(async e=>{const{_id:t,method:a,args:s}=e.data;try{if(!RPC[a])throw`method '${a}' not registered in service worker`;const c=await RPC[a](...s);e.source.postMessage({_id:t,value:c})}catch(a){const s=a?a.message||`${a}`:"unknown error";e.source.postMessage({_id:t,error:s})}}));let _cache,cacheableResources=new Set;const getCache=async()=>_cache||(_cache=await caches.open("1")),getCachedOrFetch=async e=>{const t=await getCache(),a=await t.match(e);if(a)return a;const s=await fetch(e);return t.put(e,s.clone()),s};self.addEventListener("fetch",(e=>{const{hostname:t,pathname:a,search:s}=new URL(e.request.url);t===self.location.hostname&&cacheableResources.has(a+s)&&e.respondWith(getCachedOrFetch(e.request))})),RPC.setCacheableResources=e=>{cacheableResources=new Set(e)},RPC.prefetch=async e=>{if(!cacheableResources.has(e))throw`not allowed to cache '${e}'`;await getCachedOrFetch(new Request(e))};