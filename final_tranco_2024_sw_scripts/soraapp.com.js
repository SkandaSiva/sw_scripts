class e{constructor(e="keyval-store",t="keyval",r=1,s){this.storeName=t,this._dbp=new Promise(((n,i)=>{const a=indexedDB.open(e,r);a.onerror=()=>i(a.error),a.onsuccess=()=>n(a.result),a.onupgradeneeded=e=>{let r;r=a.result.objectStoreNames.contains(t)?a.transaction.objectStore(t):a.result.createObjectStore(t),s&&s(r,e.oldVersion)}}))}_withIDBStore(e,t){return this._dbp.then((r=>new Promise(((s,n)=>{const i=r.transaction(this.storeName,e);i.oncomplete=e=>s(e),i.onabort=i.onerror=()=>n(i.error),t(i.objectStore(this.storeName))}))))}}let t;function r(){return t||(t=new e),t}class s{static get(e,t=r()){let s;return t._withIDBStore("readonly",(t=>{s=t.get(e)})).then((()=>s.result))}static set(e,t,s=r()){return s._withIDBStore("readwrite",(r=>{r.put(t,e)}))}static del(e,t=r()){return t._withIDBStore("readwrite",(t=>{t.delete(e)}))}static clear(e=r()){return e._withIDBStore("readwrite",(e=>{e.clear()}))}static keys(e=r()){const t=[];return e._withIDBStore("readonly",(e=>{(e.openKeyCursor||e.openCursor).call(e).onsuccess=function(){this.result&&(t.push(this.result.key),this.result.continue())}})).then((()=>t))}static getAllByIndex(e,t,s=r()){let n=[];return s._withIDBStore("readonly",(r=>{let s=r.index(e),i=IDBKeyRange.only(t);return s.openCursor(i).onsuccess=function(e){let t=e.target.result;if(!t)return this.transaction.oncomplete(n);n.push({key:t.primaryKey,value:t.value}),t.continue()}}))}static getAllKeysByIndex(e,t,s=r()){let n=[];return s._withIDBStore("readonly",(r=>{let s=r.index(e),i=IDBKeyRange.only(t);return s.openCursor(i).onsuccess=function(e){let t=e.target.result;if(!t)return this.transaction.oncomplete(n);n.push(t.primaryKey),t.continue()}}))}}class n extends s{static get(e){return super.get(e,this._getStore())}static set(e,t){return super.set(e,t,this._getStore())}static del(e){return super.del(e,this._getStore())}static clear(){return super.clear(this._getStore())}static keys(){return super.keys(this._getStore())}static getAllByIndex(e,t){return super.getAllByIndex(e,t,this._getStore())}static _getStore(){if(!this._dbSettings)throw"Invalid DB configuration";return this._store||(this._store=new e(this._dbSettings.name,this._dbSettings.store,this._dbSettings.version,this._dbSettings.onUpgrade)),this._store}}class i extends n{static getRosterIdsByHealth(e){return super.getAllKeysByIndex("health",e,this._getStore())}}i._dbSettings={name:"nautilus-rosters",store:"nautilus-rosters",version:2,onUpgrade:(e,t)=>{if(t<2){if(1===t)try{e.deleteIndex("cache-roster-entry")}catch(r){}e.createIndex("health","health",{multiEntry:!0})}}};class a extends n{}a._dbSettings={name:"nautilus-data",store:"nautilus-data",version:1};class o{constructor(){this._algo="AES-GCM"}async encrypt(e,t){const r=await this._getKey(!0);return crypto.subtle.encrypt({name:this._algo,iv:t},r,e)}async decrypt(e,t){const r=await this._getKey();if(!r)throw new Error("No key, unable to decrypt");return crypto.subtle.decrypt({name:this._algo,iv:t},r,e)}stringToIv(e){return e=e.padEnd(12),(new TextEncoder).encode(e).reverse().slice(0,11)}async _getKey(e=!1){if(this._key)return this._key;const t=await a.get("crypt-key");return t?(t instanceof CryptoKey?this._key=t:this._key=await crypto.subtle.importKey("raw",t,{name:this._algo,length:256},!0,["encrypt","decrypt"]),this._key):e?this._generateKey():null}async _generateKey(){const e=function(){try{const e=navigator.userAgent;if(e.match(/iPhone|iPod|iPad/))return!0;if(e.match(/Mac OS/)&&!e.match(/Chrome\//)&&e.match(/Safari\//)&&e.match(/Version\//))return!0}catch(e){console.error("[NAUTILUS] error checking if safari: ",e)}return!1}();return this._key=await crypto.subtle.generateKey({name:this._algo,length:256},e,["encrypt","decrypt"]),e?await a.set("crypt-key",await crypto.subtle.exportKey("raw",this._key)):await a.set("crypt-key",this._key),this._key}}class c{constructor(){this._proxyMap={},this._cryptKeeper=new o}get(e){const t=e.request,r=new URL(t.url);return console.debug(`[FETCH] requesting: ${t.url}`),"/api/nautilus-browser/check"===r.pathname?e.respondWith(new Response("",{status:200})):"/config"===r.pathname||"/selftest"===r.pathname||r.pathname.startsWith("/classroom-attachment")?void 0:r.origin!==self.location.origin?console.debug(`[FETCH] cross domain -> network: ${t.url}`):t.headers&&t.headers.has("X-Dervish-Prefetch")?console.debug("[FETCH] bypassing cache for prefetch request"):void e.respondWith(this._handleRequest(t,e.clientId))}async _handleRequest(e,t){let r=!1;try{const s=await this._deproxifyUrl(e,t);return console.debug(`[FETCH] After deproxify, url: ${s.request.url}, was: ${e.url}`),r=s.deproxified,await this._cacheThenNetwork(s,e)}catch(s){if(console.error("[FETCH] Error processing fetch: %O -- Deproxified?: %s",s,r),s instanceof l)return new Response("Error deproxyfying request for ID: "+s.proxyId,{status:404});if(r||"Failed to fetch"===s.message||"NetworkError when attempting to fetch resource."===s.message)throw s;return fetch(e)}}clearInvalidRosters(){this._invalidRosterIds=null}async _getProxyRoot(e){let t=this._proxyMap[e];if(t)return t;let r=await a.get(e);if(r&&(t=r.root,this._proxyMap[e]=t),!t)throw new Error("Unable to map proxy ID to entry");return t}async _deproxifyUrl(e,t){let r,s=new RegExp(/_proxy-(\w+)(\/.*)/);if(r=e.url.match(s))try{console.debug(`[FETCH] requestMatch - proxy id: ${r[1]}`);const t=await this._getProxyRoot(r[1])+r[2].substr(1);return console.debug(`[FETCH] requestMatch - proxy - updatedUrl: ${t}`),{request:this._transformRequest(e,t),deproxified:!0,ambiguousUrl:!1}}catch(n){throw console.warn(`[FETCH] Failed to find proxy entry: ${r[1]} -- exception: ${n}`),new l(r[1])}else{const i=await self.clients.get(t);if(i&&i.url&&(r=i.url.match(s))||e.referrer&&(r=e.referrer.match(s)))try{console.debug(`[FETCH] referrerMatch - proxy id: ${r[1]}`);const t=new URL(e.url),s=await this._getProxyRoot(r[1]);return t.hostname=new URL(s).hostname,{request:this._transformRequest(e,t.href),deproxified:!0,ambiguousUrl:!0}}catch(n){throw console.warn(`[FETCH] Failed to find proxy entry: ${r[1]} -- exception: ${n}`),new l(r[1])}}return{request:e,deproxified:!1,ambiguousUrl:!1}}_transformRequest(e,t){const r=this._extractAllowedHeaders(e.headers);return new Request(t,{headers:r,method:e.method,referrer:e.referrer,referrerPolicy:e.referrerPolicy,credentials:"include",cache:e.cache,redirect:e.redirect,integrity:e.integrity})}_extractAllowedHeaders(e){const t=new Headers;return e.forEach(((e,r)=>{c.REQUEST_HEADER_ALLOWLIST.includes(r)&&t.append(r,e)})),t}async _cacheThenNetwork(e,t){try{let r=await this._retrieveFromCache(e.request);if(r||"navigate"!==e.request.mode||e.deproxified){if(!r&&e.deproxified&&e.ambiguousUrl&&"image"===(null==t?void 0:t.destination)){new URL(e.request.url).pathname.startsWith("/covers/")&&(console.debug(`[FETCH] Cache miss on: ${e.request.url} -- trying original URL: ${t.url}`),r=await this._retrieveFromCache(t))}}else{const t=new URL(e.request.url);t.pathname.length>1&&!t.pathname.startsWith("/api")&&!t.pathname.match(/\.(x?html?|css|js|map)$/)&&(console.debug(`[FETCH] Cache miss on: ${e.request.url} -- now try root URL`),r=await this._retrieveFromCache(new Request(t.origin)))}if(r)return r;console.debug(`[FETCH] Cache missed, going to network for: ${e.request.url}`)}catch(r){console.error("[FETCH] Error processing request: %s -- ex: %O",e.request.url,r)}try{if(e.deproxified){console.debug(`[FETCH] Cache miss for ${e.request.url} -- assuming Dervish b/c request was deproxified`);if(new URL(e.request.url).pathname.includes("/_d/cover/"))return await this._fetchFromNetwork(e.request.url);e.request.headers.delete("range"),e.request.headers.append("X-Dervish-Prefetch","V13;manualRedirect");const t=await this._fetchFromNetwork(e.request);if(204===t.status&&t.headers.has("X-Dervish-Redirect")){const r=t.headers.get("X-Dervish-Redirect");return console.debug(`[FETCH] Dervish redirect from: ${e.request.url} -> ${r}`),await this._fetchFromNetwork(r)}if(e.ambiguousUrl){const e=new Headers(t.headers);return e.set("Cache-Control","no-store, max-age=0"),new Response(this._isNullBodyStatus(t.status)?null:t.body,{headers:e,status:t.status,statusText:t.statusText})}return t}return await this._fetchFromNetwork(e.request)}catch(s){const t=await this._retrieveFromCache(e.request,!0);if(t||s.response)return t||s.response;throw s}}async _retrieveFromCache(e,t=!1){let r=[],s=[];t?s=await this._getInvalidRosterIds():(r=await this._getInvalidRosterIds(),s=await caches.keys());for(let n=0;n<s.length;n++)if(!r.includes(s[n])){const t=await caches.open(s[n]);let r,i=await t.match(e.url);if(i||(r=new URL(new URL(e.url).pathname,"https://nautilus-browser.overdrive.com").toString(),i=await t.match(r)),i){console.debug(`[FETCH] Found cache entry for ${e.url} in ${s[n]}`);const t=await i.arrayBuffer(),a=await this._cryptKeeper.decrypt(t,this._cryptKeeper.stringToIv(r||e.url)),o=i.headers;o.get("content-length")||o.set("Content-Length",a.byteLength.toString()),"audio/mpeg"===o.get("content-type")&&o.set("Accept-Ranges","bytes"),o.set("Cache-Control","no-store, max-age=0");const c=new Response(a,{headers:i.headers,status:i.status,statusText:i.statusText});return this._isValidRangeRequest(e,c)?this._handleRangeRequest(e,c):c}}}async _handleRangeRequest(e,t){const r=await t.arrayBuffer();try{const s=this._parseRange(e.headers.get("Range"),r.byteLength),n=r.slice(s.start,s.end),i=new Response(n,{status:206,statusText:"Partial Content",headers:t.headers});return i.headers.set("Content-Length",`${n.byteLength}`),i.headers.set("Content-Range",`bytes ${s.start}-${s.end-1}/${r.byteLength}`),i}catch(s){const t=s.message.split(":");return console.warn(`[FETCH] Invalid range request for ${e.url}. Status: ${t[0]} ${t[1]}`),new Response(t[1],{status:Number(t[0])})}}_isValidRangeRequest(e,t){return!!e.headers.get("Range")&&200===t.status}_parseRange(e,t){if(!e.startsWith("bytes="))throw new Error("400:Invalid range unit");const r=/^bytes\=(\d*)\-(\d*)$/g.exec(e);if(!r[1]&&!r[2])throw new Error("400:Invalid range header");const s={start:Number(r[1]),end:t};if(""===r[1]?s.start=t-Number(r[2]):""!==r[2]&&(s.end=Number(r[2])+1),console.debug("[FETCH] range request - header: %s -- range: %O",e,s),s.start<0||s.end>t)throw new Error("416:Range Not Satisfiable");return s}async _getInvalidRosterIds(){return this._invalidRosterIds||(this._invalidRosterIds=await i.getRosterIdsByHealth("invalid")),this._invalidRosterIds}_isNullBodyStatus(e){return[101,204,205,304].includes(e)}async _fetchFromNetwork(e){const t=await fetch(e);if(t.status>=400)throw new u(t);return t}}c.REQUEST_HEADER_ALLOWLIST=["accept","accept-language","content-language","content-type","range","x-dervish-prefetch","x-dervish-decree"];class l extends Error{constructor(e){super("Unable to deproxify request"),this.name="DeproxifyError",this.proxyId=e}}class u extends Error{constructor(e){super("Fetch API failure"),this.name="FetchError",this.response=e}}const d=new Map,h=new Map;async function g(e,t,r="number"!=typeof t.notification.ms){const{id:s,ms:n}=t.notification,i=await async function({notification:e,supplement:t}){if(0===h.size){(await a.get("notification:categories")).forEach(((e,t)=>{h.set(t,e)}))}const r=h.get(e.category);return{body:e.body,data:{id:e.id,notification:e,supplement:t},icon:t.coverImageURL,actions:null==r?void 0:r.actions,badge:void 0,image:void 0}}(t);function o(){return e(t.notification.title,i,r)}if(f(s),n){const e=setTimeout((async function(){await o(),d.delete(s)}),n);d.set(s,{timeoutId:e,notificationMessage:t})}else await o()}function f(e){d.has(e)&&(clearTimeout(d.get(e).timeoutId),d.delete(e))}console.log("[NAUTILUS-SW] Starting up..."),self.addEventListener("install",(e=>{console.log("[NAUTILUS-SW] Installing..."),e.waitUntil(async function(){let e=await i.keys(),t=await caches.keys();for(let r of t)-1===e.indexOf(r)&&await caches.delete(r)}()),setTimeout((()=>{console.log("[NAUTILUS-SW] Take control..."),self.skipWaiting()}),3e4)})),self.addEventListener("activate",(e=>{console.log("[NAUTILUS-SW] Activating..."),e.waitUntil(self.clients.claim())}));let p=new c;self.addEventListener("fetch",(e=>{p.get(e)})),self.addEventListener("message",(e=>{switch(e.data.name){case"invalid-roster-update":p.clearInvalidRosters();break;case"notifier:schedule":e.waitUntil(g(w,e.data));break;case"notifier:cancel":f(e.data.notification.id);break;case"notifier:list":e.waitUntil(async function(){const e=await self.registration.getNotifications();_(await m(),{name:"notifier:list",notifications:e.map((({data:{notification:e,supplement:t}})=>({notification:e,supplement:t})))})}());break;case"notifier:dismiss":case"notifier:dismiss:all":e.waitUntil(async function(e=null){(await self.registration.getNotifications()).filter((({data:{notification:t}})=>!e||t.id===e)).forEach((e=>{e.close()}))}(e.data.id||null));break;case"notifier:categories":e.waitUntil(async function(e){e.forEach((e=>{h.set(e.category,e)})),await a.set("notification:categories",h)}(e.data.definitions));break;default:console.warn("[NAUTILUS-SW] Unhandled message",e.data.name)}})),self.addEventListener("push",(e=>{const t=e.data.json();e.waitUntil(g(w,t,!1))})),self.addEventListener("notificationclick",(e=>{const{notification:t}=e;t.close(),e.waitUntil(async function(){const e=await m();if(e)return e.focus(),e;const t=await self.clients.openWindow(self.origin);return await self.clients.claim(),t}().then((r=>{_(r,{name:"notifier:handle",notification:Object.assign(Object.assign({},t.data.notification),{action:e.action}),supplement:t.data.supplement})})))}));const y=new Map;async function w(e,t,r=!1){var s;const n=null===(s=null==t?void 0:t.data)||void 0===s?void 0:s.id,i=await m();if(!r&&"visible"===(null==i?void 0:i.visibilityState))return console.log("[NAUTILUS-SW] App is visible, sending notifier:receive instead"),_(i,{name:"notifier:receive",notification:t.data.notification,supplement:t.data.supplement}),n?new Promise((e=>{const t=setTimeout((()=>e()),50);y.set(n,(()=>{clearTimeout(t),e()}))})):void 0;let a;await self.registration.showNotification(e,t),n&&(a=y.get(n))&&(a(),y.delete(n));const o=(await self.registration.getNotifications()).find((e=>{var r,s;return(null===(r=e.data)||void 0===r?void 0:r.id)===(null===(s=t.data)||void 0===s?void 0:s.id)}));return o}async function m(){const e=await self.clients.matchAll({type:"window",includeUncontrolled:!0});return e.find((e=>"visible"===e.visibilityState))||e[0]}function _(e,t){e.postMessage(Object.assign({dest:"client"},t))}
//# sourceMappingURL=nautilus-sw.js.map
