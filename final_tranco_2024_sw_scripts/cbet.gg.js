try{self["workbox:core:6.5.4"]&&_()}catch{}const w=(s,...e)=>{let t=s;return e.length>0&&(t+=` :: ${JSON.stringify(e)}`),t},y=w;class g extends Error{constructor(e,t){const r=y(e,t);super(r),this.name=e,this.details=t}}typeof registration<"u"&&registration.scope;function H(){self.addEventListener("activate",()=>self.clients.claim())}try{self["workbox:routing:6.5.4"]&&_()}catch{}const R="GET",d=s=>s&&typeof s=="object"?s:{handle:s};class f{constructor(e,t,r=R){this.handler=d(t),this.match=e,this.method=r}setCatchHandler(e){this.catchHandler=d(e)}}class b extends f{constructor(e,t,r){const i=({url:a})=>{const o=e.exec(a.href);if(o&&!(a.origin!==location.origin&&o.index!==0))return o.slice(1)};super(i,t,r)}}class x{constructor(){this._routes=new Map,this._defaultHandlerMap=new Map}get routes(){return this._routes}addFetchListener(){self.addEventListener("fetch",e=>{const{request:t}=e,r=this.handleRequest({request:t,event:e});r&&e.respondWith(r)})}addCacheListener(){self.addEventListener("message",e=>{if(e.data&&e.data.type==="CACHE_URLS"){const{payload:t}=e.data,r=Promise.all(t.urlsToCache.map(i=>{typeof i=="string"&&(i=[i]);const a=new Request(...i);return this.handleRequest({request:a,event:e})}));e.waitUntil(r),e.ports&&e.ports[0]&&r.then(()=>e.ports[0].postMessage(!0))}})}handleRequest({request:e,event:t}){const r=new URL(e.url,location.href);if(!r.protocol.startsWith("http"))return;const i=r.origin===location.origin,{params:a,route:o}=this.findMatchingRoute({event:t,request:e,sameOrigin:i,url:r});let n=o&&o.handler;const c=e.method;if(!n&&this._defaultHandlerMap.has(c)&&(n=this._defaultHandlerMap.get(c)),!n)return;let h;try{h=n.handle({url:r,request:e,event:t,params:a})}catch(l){h=Promise.reject(l)}const m=o&&o.catchHandler;return h instanceof Promise&&(this._catchHandler||m)&&(h=h.catch(async l=>{if(m)try{return await m.handle({url:r,request:e,event:t,params:a})}catch(p){p instanceof Error&&(l=p)}if(this._catchHandler)return this._catchHandler.handle({url:r,request:e,event:t});throw l})),h}findMatchingRoute({url:e,sameOrigin:t,request:r,event:i}){const a=this._routes.get(r.method)||[];for(const o of a){let n;const c=o.match({url:e,sameOrigin:t,request:r,event:i});if(c)return n=c,(Array.isArray(n)&&n.length===0||c.constructor===Object&&Object.keys(c).length===0||typeof c=="boolean")&&(n=void 0),{route:o,params:n}}return{}}setDefaultHandler(e,t=R){this._defaultHandlerMap.set(t,d(e))}setCatchHandler(e){this._catchHandler=d(e)}registerRoute(e){this._routes.has(e.method)||this._routes.set(e.method,[]),this._routes.get(e.method).push(e)}unregisterRoute(e){if(!this._routes.has(e.method))throw new g("unregister-route-but-not-found-with-method",{method:e.method});const t=this._routes.get(e.method).indexOf(e);if(t>-1)this._routes.get(e.method).splice(t,1);else throw new g("unregister-route-route-not-registered")}}let u;const E=()=>(u||(u=new x,u.addFetchListener(),u.addCacheListener()),u);function L(s,e,t){let r;if(typeof s=="string"){const a=new URL(s,location.href),o=({url:n})=>n.href===a.href;r=new f(o,e,t)}else if(s instanceof RegExp)r=new b(s,e,t);else if(typeof s=="function")r=new f(s,e,t);else if(s instanceof f)r=s;else throw new g("unsupported-route-type",{moduleName:"workbox-routing",funcName:"registerRoute",paramName:"capture"});return E().registerRoute(r),r}self.__WB_DISABLE_DEV_LOGS=!0;self.skipWaiting();H();const k=self.serviceWorker.scriptURL.match(/version=([^&]*)/)?.[1]||"0",C=({url:s})=>s.pathname.startsWith("/back/v3/static/")?!!(s.pathname.includes("icons")||s.pathname.includes("images")||s.pathname.includes("navigation")):!1,M=async({url:s,request:e})=>fetch(new Request(s.href+"?"+k,e));L(C,M);
