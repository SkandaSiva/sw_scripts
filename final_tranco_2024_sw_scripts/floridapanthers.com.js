(function(){"use strict";var ie={436:function(){try{self["workbox:core:6.5.3"]&&_()}catch{}},388:function(){try{self["workbox:expiration:6.5.3"]&&_()}catch{}},25:function(){try{self["workbox:precaching:6.5.3"]&&_()}catch{}},387:function(){try{self["workbox:routing:6.5.3"]&&_()}catch{}},338:function(){try{self["workbox:strategies:6.5.3"]&&_()}catch{}}},F={};function y(u){var D=F[u];if(D!==void 0)return D.exports;var b=F[u]={exports:{}};return ie[u](b,b.exports,y),b.exports}var Ge={};(function(){var u=y(436);const D={"invalid-value":({paramName:r,validValueDescription:e,value:t})=>{if(!r||!e)throw new Error("Unexpected input to 'invalid-value' error.");return`The '${r}' parameter was given a value with an unexpected value. ${e} Received a value of ${JSON.stringify(t)}.`},"not-an-array":({moduleName:r,className:e,funcName:t,paramName:s})=>{if(!r||!e||!t||!s)throw new Error("Unexpected input to 'not-an-array' error.");return`The parameter '${s}' passed into '${r}.${e}.${t}()' must be an array.`},"incorrect-type":({expectedType:r,paramName:e,moduleName:t,className:s,funcName:n})=>{if(!r||!e||!t||!n)throw new Error("Unexpected input to 'incorrect-type' error.");const a=s?`${s}.`:"";return`The parameter '${e}' passed into '${t}.${a}${n}()' must be of type ${r}.`},"incorrect-class":({expectedClassName:r,paramName:e,moduleName:t,className:s,funcName:n,isReturnValueProblem:a})=>{if(!r||!t||!n)throw new Error("Unexpected input to 'incorrect-class' error.");const i=s?`${s}.`:"";return a?`The return value from '${t}.${i}${n}()' must be an instance of class ${r}.`:`The parameter '${e}' passed into '${t}.${i}${n}()' must be an instance of class ${r}.`},"missing-a-method":({expectedMethod:r,paramName:e,moduleName:t,className:s,funcName:n})=>{if(!r||!e||!t||!s||!n)throw new Error("Unexpected input to 'missing-a-method' error.");return`${t}.${s}.${n}() expected the '${e}' parameter to expose a '${r}' method.`},"add-to-cache-list-unexpected-type":({entry:r})=>`An unexpected entry was passed to 'workbox-precaching.PrecacheController.addToCacheList()' The entry '${JSON.stringify(r)}' isn't supported. You must supply an array of strings with one or more characters, objects with a url property or Request objects.`,"add-to-cache-list-conflicting-entries":({firstEntry:r,secondEntry:e})=>{if(!r||!e)throw new Error("Unexpected input to 'add-to-cache-list-duplicate-entries' error.");return`Two of the entries passed to 'workbox-precaching.PrecacheController.addToCacheList()' had the URL ${r} but different revision details. Workbox is unable to cache and version the asset correctly. Please remove one of the entries.`},"plugin-error-request-will-fetch":({thrownErrorMessage:r})=>{if(!r)throw new Error("Unexpected input to 'plugin-error-request-will-fetch', error.");return`An error was thrown by a plugins 'requestWillFetch()' method. The thrown error message was: '${r}'.`},"invalid-cache-name":({cacheNameId:r,value:e})=>{if(!r)throw new Error("Expected a 'cacheNameId' for error 'invalid-cache-name'");return`You must provide a name containing at least one character for setCacheDetails({${r}: '...'}). Received a value of '${JSON.stringify(e)}'`},"unregister-route-but-not-found-with-method":({method:r})=>{if(!r)throw new Error("Unexpected input to 'unregister-route-but-not-found-with-method' error.");return`The route you're trying to unregister was not  previously registered for the method type '${r}'.`},"unregister-route-route-not-registered":()=>"The route you're trying to unregister was not previously registered.","queue-replay-failed":({name:r})=>`Replaying the background sync queue '${r}' failed.`,"duplicate-queue-name":({name:r})=>`The Queue name '${r}' is already being used. All instances of backgroundSync.Queue must be given unique names.`,"expired-test-without-max-age":({methodName:r,paramName:e})=>`The '${r}()' method can only be used when the '${e}' is used in the constructor.`,"unsupported-route-type":({moduleName:r,className:e,funcName:t,paramName:s})=>`The supplied '${s}' parameter was an unsupported type. Please check the docs for ${r}.${e}.${t} for valid input types.`,"not-array-of-class":({value:r,expectedClass:e,moduleName:t,className:s,funcName:n,paramName:a})=>`The supplied '${a}' parameter must be an array of '${e}' objects. Received '${JSON.stringify(r)},'. Please check the call to ${t}.${s}.${n}() to fix the issue.`,"max-entries-or-age-required":({moduleName:r,className:e,funcName:t})=>`You must define either config.maxEntries or config.maxAgeSecondsin ${r}.${e}.${t}`,"statuses-or-headers-required":({moduleName:r,className:e,funcName:t})=>`You must define either config.statuses or config.headersin ${r}.${e}.${t}`,"invalid-string":({moduleName:r,funcName:e,paramName:t})=>{if(!t||!r||!e)throw new Error("Unexpected input to 'invalid-string' error.");return`When using strings, the '${t}' parameter must start with 'http' (for cross-origin matches) or '/' (for same-origin matches). Please see the docs for ${r}.${e}() for more info.`},"channel-name-required":()=>"You must provide a channelName to construct a BroadcastCacheUpdate instance.","invalid-responses-are-same-args":()=>"The arguments passed into responsesAreSame() appear to be invalid. Please ensure valid Responses are used.","expire-custom-caches-only":()=>"You must provide a 'cacheName' property when using the expiration plugin with a runtime caching strategy.","unit-must-be-bytes":({normalizedRangeHeader:r})=>{if(!r)throw new Error("Unexpected input to 'unit-must-be-bytes' error.");return`The 'unit' portion of the Range header must be set to 'bytes'. The Range header provided was "${r}"`},"single-range-only":({normalizedRangeHeader:r})=>{if(!r)throw new Error("Unexpected input to 'single-range-only' error.");return`Multiple ranges are not supported. Please use a  single start value, and optional end value. The Range header provided was "${r}"`},"invalid-range-values":({normalizedRangeHeader:r})=>{if(!r)throw new Error("Unexpected input to 'invalid-range-values' error.");return`The Range header is missing both start and end values. At least one of those values is needed. The Range header provided was "${r}"`},"no-range-header":()=>"No Range header was found in the Request provided.","range-not-satisfiable":({size:r,start:e,end:t})=>`The start (${e}) and end (${t}) values in the Range are not satisfiable by the cached response, which is ${r} bytes.`,"attempt-to-cache-non-get-request":({url:r,method:e})=>`Unable to cache '${r}' because it is a '${e}' request and only 'GET' requests can be cached.`,"cache-put-with-no-response":({url:r})=>`There was an attempt to cache '${r}' but the response was not defined.`,"no-response":({url:r,error:e})=>{let t=`The strategy could not generate a response for '${r}'.`;return e&&(t+=` The underlying error is ${e}.`),t},"bad-precaching-response":({url:r,status:e})=>`The precaching request for '${r}' failed`+(e?` with an HTTP status of ${e}.`:"."),"non-precached-url":({url:r})=>`createHandlerBoundToURL('${r}') was called, but that URL is not precached. Please pass in a URL that is precached instead.`,"add-to-cache-list-conflicting-integrities":({url:r})=>`Two of the entries passed to 'workbox-precaching.PrecacheController.addToCacheList()' had the URL ${r} with different integrity values. Please remove one of them.`,"missing-precache-entry":({cacheName:r,url:e})=>`Unable to find a precached response in ${r} for ${e}.`,"cross-origin-copy-response":({origin:r})=>`workbox-core.copyResponse() can only be used with same-origin responses. It was passed a response with origin ${r}.`,"opaque-streams-source":({type:r})=>{const e=`One of the workbox-streams sources resulted in an '${r}' response.`;return r==="opaqueredirect"?`${e} Please do not use a navigation request that results in a redirect as a source.`:`${e} Please ensure your sources are CORS-enabled.`}},b=(r,...e)=>{let t=r;return e.length>0&&(t+=` :: ${JSON.stringify(e)}`),t},Je=(r,e={})=>{const t=messages[r];if(!t)throw new Error(`Unable to find message for code '${r}'.`);return t(e)},oe=b;class h extends Error{constructor(e,t){const s=oe(e,t);super(s),this.name=e,this.details=t}}const Ye=(r,e)=>{if(!Array.isArray(r))throw new WorkboxError("not-an-array",e)},Xe=(r,e,t)=>{if(typeof r[e]!=="function")throw t.expectedMethod=e,new WorkboxError("missing-a-method",t)},Ze=(r,e,t)=>{if(typeof r!==e)throw t.expectedType=e,new WorkboxError("incorrect-type",t)},ze=(r,e,t)=>{if(!(r instanceof e))throw t.expectedClassName=e.name,new WorkboxError("incorrect-class",t)},et=(r,e,t)=>{if(!e.includes(r))throw t.validValueDescription=`Valid values are ${JSON.stringify(e)}.`,new WorkboxError("invalid-value",t)},tt=(r,e,t)=>{const s=new WorkboxError("not-array-of-class",t);if(!Array.isArray(r))throw s;for(const n of r)if(!(n instanceof e))throw s},rt=null,f={googleAnalytics:"googleAnalytics",precache:"precache-v2",prefix:"workbox",runtime:"runtime",suffix:typeof registration<"u"?registration.scope:""},L=r=>[f.prefix,r,f.suffix].filter(e=>e&&e.length>0).join("-"),ce=r=>{for(const e of Object.keys(f))r(e)},k={updateDetails:r=>{ce(e=>{typeof r[e]=="string"&&(f[e]=r[e])})},getGoogleAnalyticsName:r=>r||L(f.googleAnalytics),getPrecacheName:r=>r||L(f.precache),getPrefix:()=>f.prefix,getRuntimeName:r=>r||L(f.runtime),getSuffix:()=>f.suffix},O=null;function j(r,e){const t=e();return r.waitUntil(t),t}var st=y(25);const le="__WB_REVISION__";function he(r){if(!r)throw new h("add-to-cache-list-unexpected-type",{entry:r});if(typeof r=="string"){const a=new URL(r,location.href);return{cacheKey:a.href,url:a.href}}const{revision:e,url:t}=r;if(!t)throw new h("add-to-cache-list-unexpected-type",{entry:r});if(!e){const a=new URL(t,location.href);return{cacheKey:a.href,url:a.href}}const s=new URL(t,location.href),n=new URL(t,location.href);return s.searchParams.set(le,e),{cacheKey:s.href,url:n.href}}class ue{constructor(){this.updatedURLs=[],this.notUpdatedURLs=[],this.handlerWillStart=async({request:e,state:t})=>{t&&(t.originalRequest=e)},this.cachedResponseWillBeUsed=async({event:e,state:t,cachedResponse:s})=>{if(e.type==="install"&&t&&t.originalRequest&&t.originalRequest instanceof Request){const n=t.originalRequest.url;s?this.notUpdatedURLs.push(n):this.updatedURLs.push(n)}return s}}}class fe{constructor({precacheController:e}){this.cacheKeyWillBeUsed=async({request:t,params:s})=>{const n=s?.cacheKey||this._precacheController.getCacheKeyForURL(t.url);return n?new Request(n,{headers:t.headers}):t},this._precacheController=e}}const de=(r,e)=>{logger.groupCollapsed(r);for(const t of e)logger.log(t);logger.groupEnd()};function nt(r){const e=r.length;e>0&&(logger.groupCollapsed(`During precaching cleanup, ${e} cached request${e===1?" was":"s were"} deleted.`),de("Deleted Cache Requests",r),logger.groupEnd())}function H(r,e){if(e.length!==0){logger.groupCollapsed(r);for(const t of e)logger.log(t);logger.groupEnd()}}function at(r,e){const t=r.length,s=e.length;if(t||s){let n=`Precaching ${t} file${t===1?"":"s"}.`;s>0&&(n+=` ${s} file${s===1?" is":"s are"} already cached.`),logger.groupCollapsed(n),H("View newly precached URLs.",r),H("View previously precached URLs.",e),logger.groupEnd()}}let R;function pe(){if(R===void 0){const r=new Response("");if("body"in r)try{new Response(r.body),R=!0}catch{R=!1}R=!1}return R}async function ge(r,e){let t=null;if(r.url&&(t=new URL(r.url).origin),t!==self.location.origin)throw new h("cross-origin-copy-response",{origin:t});const s=r.clone(),n={headers:new Headers(s.headers),status:s.status,statusText:s.statusText},a=e?e(n):n,i=pe()?s.body:await s.blob();return new Response(i,a)}const V=r=>new URL(String(r),location.href).href.replace(new RegExp(`^${location.origin}`),"");function Q(r,e){const t=new URL(r);for(const s of e)t.searchParams.delete(s);return t.href}async function we(r,e,t,s){const n=Q(e.url,t);if(e.url===n)return r.match(e,s);const a=Object.assign(Object.assign({},s),{ignoreSearch:!0}),i=await r.keys(e,a);for(const o of i){const c=Q(o.url,t);if(n===c)return r.match(o,s)}}class me{constructor(){this.promise=new Promise((e,t)=>{this.resolve=e,this.reject=t})}}const G=new Set;async function ye(){for(const r of G)await r()}function _e(r){return new Promise(e=>setTimeout(e,r))}var it=y(338);function P(r){return typeof r=="string"?new Request(r):r}class be{constructor(e,t){this._cacheKeys={},Object.assign(this,t),this.event=t.event,this._strategy=e,this._handlerDeferred=new me,this._extendLifetimePromises=[],this._plugins=[...e.plugins],this._pluginStateMap=new Map;for(const s of this._plugins)this._pluginStateMap.set(s,{});this.event.waitUntil(this._handlerDeferred.promise)}async fetch(e){const{event:t}=this;let s=P(e);if(s.mode==="navigate"&&t instanceof FetchEvent&&t.preloadResponse){const i=await t.preloadResponse;if(i)return i}const n=this.hasCallback("fetchDidFail")?s.clone():null;try{for(const i of this.iterateCallbacks("requestWillFetch"))s=await i({request:s.clone(),event:t})}catch(i){if(i instanceof Error)throw new h("plugin-error-request-will-fetch",{thrownErrorMessage:i.message})}const a=s.clone();try{let i;i=await fetch(s,s.mode==="navigate"?void 0:this._strategy.fetchOptions);for(const o of this.iterateCallbacks("fetchDidSucceed"))i=await o({event:t,request:a,response:i});return i}catch(i){throw n&&await this.runCallbacks("fetchDidFail",{error:i,event:t,originalRequest:n.clone(),request:a.clone()}),i}}async fetchAndCachePut(e){const t=await this.fetch(e),s=t.clone();return this.waitUntil(this.cachePut(e,s)),t}async cacheMatch(e){const t=P(e);let s;const{cacheName:n,matchOptions:a}=this._strategy,i=await this.getCacheKey(t,"read"),o=Object.assign(Object.assign({},a),{cacheName:n});s=await caches.match(i,o);for(const c of this.iterateCallbacks("cachedResponseWillBeUsed"))s=await c({cacheName:n,matchOptions:a,cachedResponse:s,request:i,event:this.event})||void 0;return s}async cachePut(e,t){const s=P(e);await _e(0);const n=await this.getCacheKey(s,"write");if(!t)throw new h("cache-put-with-no-response",{url:V(n.url)});const a=await this._ensureResponseSafeToCache(t);if(!a)return!1;const{cacheName:i,matchOptions:o}=this._strategy,c=await self.caches.open(i),l=this.hasCallback("cacheDidUpdate"),m=l?await we(c,n.clone(),["__WB_REVISION__"],o):null;try{await c.put(n,l?a.clone():a)}catch(p){if(p instanceof Error)throw p.name==="QuotaExceededError"&&await ye(),p}for(const p of this.iterateCallbacks("cacheDidUpdate"))await p({cacheName:i,oldResponse:m,newResponse:a.clone(),request:n,event:this.event});return!0}async getCacheKey(e,t){const s=`${e.url} | ${t}`;if(!this._cacheKeys[s]){let n=e;for(const a of this.iterateCallbacks("cacheKeyWillBeUsed"))n=P(await a({mode:t,request:n,event:this.event,params:this.params}));this._cacheKeys[s]=n}return this._cacheKeys[s]}hasCallback(e){for(const t of this._strategy.plugins)if(e in t)return!0;return!1}async runCallbacks(e,t){for(const s of this.iterateCallbacks(e))await s(t)}*iterateCallbacks(e){for(const t of this._strategy.plugins)if(typeof t[e]=="function"){const s=this._pluginStateMap.get(t);yield a=>{const i=Object.assign(Object.assign({},a),{state:s});return t[e](i)}}}waitUntil(e){return this._extendLifetimePromises.push(e),e}async doneWaiting(){let e;for(;e=this._extendLifetimePromises.shift();)await e}destroy(){this._handlerDeferred.resolve(null)}async _ensureResponseSafeToCache(e){let t=e,s=!1;for(const n of this.iterateCallbacks("cacheWillUpdate"))if(t=await n({request:this.request,response:t,event:this.event})||void 0,s=!0,!t)break;return s||t&&t.status!==200&&(t=void 0),t}}class S{constructor(e={}){this.cacheName=k.getRuntimeName(e.cacheName),this.plugins=e.plugins||[],this.fetchOptions=e.fetchOptions,this.matchOptions=e.matchOptions}handle(e){const[t]=this.handleAll(e);return t}handleAll(e){e instanceof FetchEvent&&(e={event:e,request:e.request});const t=e.event,s=typeof e.request=="string"?new Request(e.request):e.request,n="params"in e?e.params:void 0,a=new be(this,{event:t,request:s,params:n}),i=this._getResponse(a,s,t),o=this._awaitComplete(i,a,s,t);return[i,o]}async _getResponse(e,t,s){await e.runCallbacks("handlerWillStart",{event:s,request:t});let n;try{if(n=await this._handle(t,e),!n||n.type==="error")throw new h("no-response",{url:t.url})}catch(a){if(a instanceof Error){for(const i of e.iterateCallbacks("handlerDidError"))if(n=await i({error:a,event:s,request:t}),n)break}if(!n)throw a}for(const a of e.iterateCallbacks("handlerWillRespond"))n=await a({event:s,request:t,response:n});return n}async _awaitComplete(e,t,s,n){let a,i;try{a=await e}catch{}try{await t.runCallbacks("handlerDidRespond",{event:n,request:s,response:a}),await t.doneWaiting()}catch(o){o instanceof Error&&(i=o)}if(await t.runCallbacks("handlerDidComplete",{event:n,request:s,response:a,error:i}),t.destroy(),i)throw i}}class g extends S{constructor(e={}){e.cacheName=k.getPrecacheName(e.cacheName),super(e),this._fallbackToNetwork=e.fallbackToNetwork!==!1,this.plugins.push(g.copyRedirectedCacheableResponsesPlugin)}async _handle(e,t){const s=await t.cacheMatch(e);return s||(t.event&&t.event.type==="install"?await this._handleInstall(e,t):await this._handleFetch(e,t))}async _handleFetch(e,t){let s;const n=t.params||{};if(this._fallbackToNetwork){const a=n.integrity,i=e.integrity,o=!i||i===a;if(s=await t.fetch(new Request(e,{integrity:e.mode!=="no-cors"?i||a:void 0})),a&&o&&e.mode!=="no-cors"){this._useDefaultCacheabilityPluginIfNeeded();const c=await t.cachePut(e,s.clone())}}else throw new h("missing-precache-entry",{cacheName:this.cacheName,url:e.url});return s}async _handleInstall(e,t){this._useDefaultCacheabilityPluginIfNeeded();const s=await t.fetch(e);if(!await t.cachePut(e,s.clone()))throw new h("bad-precaching-response",{url:e.url,status:s.status});return s}_useDefaultCacheabilityPluginIfNeeded(){let e=null,t=0;for(const[s,n]of this.plugins.entries())n!==g.copyRedirectedCacheableResponsesPlugin&&(n===g.defaultPrecacheCacheabilityPlugin&&(e=s),n.cacheWillUpdate&&t++);t===0?this.plugins.push(g.defaultPrecacheCacheabilityPlugin):t>1&&e!==null&&this.plugins.splice(e,1)}}g.defaultPrecacheCacheabilityPlugin={async cacheWillUpdate({response:r}){return!r||r.status>=400?null:r}},g.copyRedirectedCacheableResponsesPlugin={async cacheWillUpdate({response:r}){return r.redirected?await ge(r):r}};class Re{constructor({cacheName:e,plugins:t=[],fallbackToNetwork:s=!0}={}){this._urlsToCacheKeys=new Map,this._urlsToCacheModes=new Map,this._cacheKeysToIntegrities=new Map,this._strategy=new g({cacheName:k.getPrecacheName(e),plugins:[...t,new fe({precacheController:this})],fallbackToNetwork:s}),this.install=this.install.bind(this),this.activate=this.activate.bind(this)}get strategy(){return this._strategy}precache(e){this.addToCacheList(e),this._installAndActiveListenersAdded||(self.addEventListener("install",this.install),self.addEventListener("activate",this.activate),this._installAndActiveListenersAdded=!0)}addToCacheList(e){const t=[];for(const s of e){typeof s=="string"?t.push(s):s&&s.revision===void 0&&t.push(s.url);const{cacheKey:n,url:a}=he(s),i=typeof s!="string"&&s.revision?"reload":"default";if(this._urlsToCacheKeys.has(a)&&this._urlsToCacheKeys.get(a)!==n)throw new h("add-to-cache-list-conflicting-entries",{firstEntry:this._urlsToCacheKeys.get(a),secondEntry:n});if(typeof s!="string"&&s.integrity){if(this._cacheKeysToIntegrities.has(n)&&this._cacheKeysToIntegrities.get(n)!==s.integrity)throw new h("add-to-cache-list-conflicting-integrities",{url:a});this._cacheKeysToIntegrities.set(n,s.integrity)}if(this._urlsToCacheKeys.set(a,n),this._urlsToCacheModes.set(a,i),t.length>0){const o=`Workbox is precaching URLs without revision info: ${t.join(", ")}
This is generally NOT safe. Learn more at https://bit.ly/wb-precache`;console.warn(o)}}}install(e){return j(e,async()=>{const t=new ue;this.strategy.plugins.push(t);for(const[a,i]of this._urlsToCacheKeys){const o=this._cacheKeysToIntegrities.get(i),c=this._urlsToCacheModes.get(a),l=new Request(a,{integrity:o,cache:c,credentials:"same-origin"});await Promise.all(this.strategy.handleAll({params:{cacheKey:i},request:l,event:e}))}const{updatedURLs:s,notUpdatedURLs:n}=t;return{updatedURLs:s,notUpdatedURLs:n}})}activate(e){return j(e,async()=>{const t=await self.caches.open(this.strategy.cacheName),s=await t.keys(),n=new Set(this._urlsToCacheKeys.values()),a=[];for(const i of s)n.has(i.url)||(await t.delete(i),a.push(i.url));return{deletedURLs:a}})}getURLsToCacheKeys(){return this._urlsToCacheKeys}getCachedURLs(){return[...this._urlsToCacheKeys.keys()]}getCacheKeyForURL(e){const t=new URL(e,location.href);return this._urlsToCacheKeys.get(t.href)}getIntegrityForCacheKey(e){return this._cacheKeysToIntegrities.get(e)}async matchPrecache(e){const t=e instanceof Request?e.url:e,s=this.getCacheKeyForURL(t);if(s)return(await self.caches.open(this.strategy.cacheName)).match(s)}createHandlerBoundToURL(e){const t=this.getCacheKeyForURL(e);if(!t)throw new h("non-precached-url",{url:e});return s=>(s.request=new Request(e),s.params=Object.assign({cacheKey:t},s.params),this.strategy.handle(s))}}let A;const J=()=>(A||(A=new Re),A);function ot(r){getOrCreatePrecacheController().strategy.plugins.push(...r)}var ct=y(387);const Y="GET",lt=null,U=r=>r&&typeof r=="object"?r:{handle:r};class C{constructor(e,t,s=Y){this.handler=U(t),this.match=e,this.method=s}setCatchHandler(e){this.catchHandler=U(e)}}class Ce extends C{constructor(e,t,s){const n=({url:a})=>{const i=e.exec(a.href);if(i&&!(a.origin!==location.origin&&i.index!==0))return i.slice(1)};super(n,t,s)}}class xe{constructor(){this._routes=new Map,this._defaultHandlerMap=new Map}get routes(){return this._routes}addFetchListener(){self.addEventListener("fetch",e=>{const{request:t}=e,s=this.handleRequest({request:t,event:e});s&&e.respondWith(s)})}addCacheListener(){self.addEventListener("message",e=>{if(e.data&&e.data.type==="CACHE_URLS"){const{payload:t}=e.data,s=Promise.all(t.urlsToCache.map(n=>{typeof n=="string"&&(n=[n]);const a=new Request(...n);return this.handleRequest({request:a,event:e})}));e.waitUntil(s),e.ports&&e.ports[0]&&s.then(()=>e.ports[0].postMessage(!0))}})}handleRequest({request:e,event:t}){const s=new URL(e.url,location.href);if(!s.protocol.startsWith("http"))return;const n=s.origin===location.origin,{params:a,route:i}=this.findMatchingRoute({event:t,request:e,sameOrigin:n,url:s});let o=i&&i.handler;const c=[],l=e.method;if(!o&&this._defaultHandlerMap.has(l)&&(o=this._defaultHandlerMap.get(l)),!o)return;let m;try{m=o.handle({url:s,request:e,event:t,params:a})}catch($){m=Promise.reject($)}const p=i&&i.catchHandler;return m instanceof Promise&&(this._catchHandler||p)&&(m=m.catch(async $=>{if(p)try{return await p.handle({url:s,request:e,event:t,params:a})}catch(ae){ae instanceof Error&&($=ae)}if(this._catchHandler)return this._catchHandler.handle({url:s,request:e,event:t});throw $})),m}findMatchingRoute({url:e,sameOrigin:t,request:s,event:n}){const a=this._routes.get(s.method)||[];for(const i of a){let o;const c=i.match({url:e,sameOrigin:t,request:s,event:n});if(c)return o=c,(Array.isArray(o)&&o.length===0||c.constructor===Object&&Object.keys(c).length===0||typeof c=="boolean")&&(o=void 0),{route:i,params:o}}return{}}setDefaultHandler(e,t=Y){this._defaultHandlerMap.set(t,U(e))}setCatchHandler(e){this._catchHandler=U(e)}registerRoute(e){this._routes.has(e.method)||this._routes.set(e.method,[]),this._routes.get(e.method).push(e)}unregisterRoute(e){if(!this._routes.has(e.method))throw new h("unregister-route-but-not-found-with-method",{method:e.method});const t=this._routes.get(e.method).indexOf(e);if(t>-1)this._routes.get(e.method).splice(t,1);else throw new h("unregister-route-route-not-registered")}}let x;const Ee=()=>(x||(x=new xe,x.addFetchListener(),x.addCacheListener()),x);function w(r,e,t){let s;if(typeof r=="string"){const a=new URL(r,location.href),i=({url:o})=>o.href===a.href;s=new C(i,e,t)}else if(r instanceof RegExp)s=new Ce(r,e,t);else if(typeof r=="function")s=new C(r,e,t);else if(r instanceof C)s=r;else throw new h("unsupported-route-type",{moduleName:"workbox-routing",funcName:"registerRoute",paramName:"capture"});return Ee().registerRoute(s),s}function Te(r,e=[]){for(const t of[...r.searchParams.keys()])e.some(s=>s.test(t))&&r.searchParams.delete(t);return r}function*ke(r,{ignoreURLParametersMatching:e=[/^utm_/,/^fbclid$/],directoryIndex:t="index.html",cleanURLs:s=!0,urlManipulation:n}={}){const a=new URL(r,location.href);a.hash="",yield a.href;const i=Te(a,e);if(yield i.href,t&&i.pathname.endsWith("/")){const o=new URL(i.href);o.pathname+=t,yield o.href}if(s){const o=new URL(i.href);o.pathname+=".html",yield o.href}if(n){const o=n({url:a});for(const c of o)yield c.href}}class Pe extends C{constructor(e,t){const s=({request:n})=>{const a=e.getURLsToCacheKeys();for(const i of ke(n.url,t)){const o=a.get(i);if(o){const c=e.getIntegrityForCacheKey(o);return{cacheKey:o,integrity:c}}}};super(s,e.strategy)}}function Ue(r){const e=J(),t=new Pe(e,r);w(t)}const ve="-precache-",ht=async(r,e=ve)=>{const s=(await self.caches.keys()).filter(n=>n.includes(e)&&n.includes(self.registration.scope)&&n!==r);return await Promise.all(s.map(n=>self.caches.delete(n))),s};function ut(){self.addEventListener("activate",r=>{const e=cacheNames.getPrecacheName();r.waitUntil(deleteOutdatedCaches(e).then(t=>{}))})}function ft(r){return getOrCreatePrecacheController().createHandlerBoundToURL(r)}function dt(r){return getOrCreatePrecacheController().getCacheKeyForURL(r)}function pt(r){return getOrCreatePrecacheController().matchPrecache(r)}function $e(r){J().precache(r)}function De(r,e){$e(r),Ue(e)}class gt{constructor({fallbackURL:e,precacheController:t}){this.handlerDidError=()=>this._precacheController.matchPrecache(this._fallbackURL),this._fallbackURL=e,this._precacheController=t||getOrCreatePrecacheController()}}class wt extends null{constructor(e,{allowlist:t=[/./],denylist:s=[]}={}){super(n=>this._match(n),e),this._allowlist=t,this._denylist=s}_match({url:e,request:t}){if(t&&t.mode!=="navigate")return!1;const s=e.pathname+e.search;for(const n of this._denylist)if(n.test(s))return!1;return!!this._allowlist.some(n=>n.test(s))}}function mt(r){getOrCreateDefaultRouter().setCatchHandler(r)}function yt(r){getOrCreateDefaultRouter().setDefaultHandler(r)}function X(r){r.then(()=>{})}const Le=(r,e)=>e.some(t=>r instanceof t);let Z,z;function Oe(){return Z||(Z=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}function Se(){return z||(z=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}const ee=new WeakMap,M=new WeakMap,te=new WeakMap,N=new WeakMap,I=new WeakMap;function Ae(r){const e=new Promise((t,s)=>{const n=()=>{r.removeEventListener("success",a),r.removeEventListener("error",i)},a=()=>{t(d(r.result)),n()},i=()=>{s(r.error),n()};r.addEventListener("success",a),r.addEventListener("error",i)});return e.then(t=>{t instanceof IDBCursor&&ee.set(t,r)}).catch(()=>{}),I.set(e,r),e}function Me(r){if(M.has(r))return;const e=new Promise((t,s)=>{const n=()=>{r.removeEventListener("complete",a),r.removeEventListener("error",i),r.removeEventListener("abort",i)},a=()=>{t(),n()},i=()=>{s(r.error||new DOMException("AbortError","AbortError")),n()};r.addEventListener("complete",a),r.addEventListener("error",i),r.addEventListener("abort",i)});M.set(r,e)}let K={get(r,e,t){if(r instanceof IDBTransaction){if(e==="done")return M.get(r);if(e==="objectStoreNames")return r.objectStoreNames||te.get(r);if(e==="store")return t.objectStoreNames[1]?void 0:t.objectStore(t.objectStoreNames[0])}return d(r[e])},set(r,e,t){return r[e]=t,!0},has(r,e){return r instanceof IDBTransaction&&(e==="done"||e==="store")?!0:e in r}};function Ne(r){K=r(K)}function Ie(r){return r===IDBDatabase.prototype.transaction&&!("objectStoreNames"in IDBTransaction.prototype)?function(e,...t){const s=r.call(W(this),e,...t);return te.set(s,e.sort?e.sort():[e]),d(s)}:Se().includes(r)?function(...e){return r.apply(W(this),e),d(ee.get(this))}:function(...e){return d(r.apply(W(this),e))}}function Ke(r){return typeof r=="function"?Ie(r):(r instanceof IDBTransaction&&Me(r),Le(r,Oe())?new Proxy(r,K):r)}function d(r){if(r instanceof IDBRequest)return Ae(r);if(N.has(r))return N.get(r);const e=Ke(r);return e!==r&&(N.set(r,e),I.set(e,r)),e}const W=r=>I.get(r);function We(r,e,{blocked:t,upgrade:s,blocking:n,terminated:a}={}){const i=indexedDB.open(r,e),o=d(i);return s&&i.addEventListener("upgradeneeded",c=>{s(d(i.result),c.oldVersion,c.newVersion,d(i.transaction),c)}),t&&i.addEventListener("blocked",c=>t(c.oldVersion,c.newVersion,c)),o.then(c=>{a&&c.addEventListener("close",()=>a()),n&&c.addEventListener("versionchange",l=>n(l.oldVersion,l.newVersion,l))}).catch(()=>{}),o}function qe(r,{blocked:e}={}){const t=indexedDB.deleteDatabase(r);return e&&t.addEventListener("blocked",s=>e(s.oldVersion,s)),d(t).then(()=>{})}const Be=["get","getKey","getAll","getAllKeys","count"],Fe=["put","add","delete","clear"],q=new Map;function re(r,e){if(!(r instanceof IDBDatabase&&!(e in r)&&typeof e=="string"))return;if(q.get(e))return q.get(e);const t=e.replace(/FromIndex$/,""),s=e!==t,n=Fe.includes(t);if(!(t in(s?IDBIndex:IDBObjectStore).prototype)||!(n||Be.includes(t)))return;const a=async function(i,...o){const c=this.transaction(i,n?"readwrite":"readonly");let l=c.store;return s&&(l=l.index(o.shift())),(await Promise.all([l[t](...o),n&&c.done]))[0]};return q.set(e,a),a}Ne(r=>({...r,get:(e,t,s)=>re(e,t)||r.get(e,t,s),has:(e,t)=>!!re(e,t)||r.has(e,t)}));var _t=y(388);const je="workbox-expiration",E="cache-entries",se=r=>{const e=new URL(r,location.href);return e.hash="",e.href};class He{constructor(e){this._db=null,this._cacheName=e}_upgradeDb(e){const t=e.createObjectStore(E,{keyPath:"id"});t.createIndex("cacheName","cacheName",{unique:!1}),t.createIndex("timestamp","timestamp",{unique:!1})}_upgradeDbAndDeleteOldDbs(e){this._upgradeDb(e),this._cacheName&&qe(this._cacheName)}async setTimestamp(e,t){e=se(e);const s={url:e,timestamp:t,cacheName:this._cacheName,id:this._getId(e)},a=(await this.getDb()).transaction(E,"readwrite",{durability:"relaxed"});await a.store.put(s),await a.done}async getTimestamp(e){const s=await(await this.getDb()).get(E,this._getId(e));return s?.timestamp}async expireEntries(e,t){const s=await this.getDb();let n=await s.transaction(E).store.index("timestamp").openCursor(null,"prev");const a=[];let i=0;for(;n;){const c=n.value;c.cacheName===this._cacheName&&(e&&c.timestamp<e||t&&i>=t?a.push(n.value):i++),n=await n.continue()}const o=[];for(const c of a)await s.delete(E,c.id),o.push(c.url);return o}_getId(e){return this._cacheName+"|"+se(e)}async getDb(){return this._db||(this._db=await We(je,1,{upgrade:this._upgradeDbAndDeleteOldDbs.bind(this)})),this._db}}class Ve{constructor(e,t={}){this._isRunning=!1,this._rerunRequested=!1,this._maxEntries=t.maxEntries,this._maxAgeSeconds=t.maxAgeSeconds,this._matchOptions=t.matchOptions,this._cacheName=e,this._timestampModel=new He(e)}async expireEntries(){if(this._isRunning){this._rerunRequested=!0;return}this._isRunning=!0;const e=this._maxAgeSeconds?Date.now()-this._maxAgeSeconds*1e3:0,t=await this._timestampModel.expireEntries(e,this._maxEntries),s=await self.caches.open(this._cacheName);for(const n of t)await s.delete(n,this._matchOptions);this._isRunning=!1,this._rerunRequested&&(this._rerunRequested=!1,X(this.expireEntries()))}async updateTimestamp(e){await this._timestampModel.setTimestamp(e,Date.now())}async isURLExpired(e){if(this._maxAgeSeconds){const t=await this._timestampModel.getTimestamp(e),s=Date.now()-this._maxAgeSeconds*1e3;return t!==void 0?t<s:!0}else return!1}async delete(){this._rerunRequested=!1,await this._timestampModel.expireEntries(1/0)}}function Qe(r){G.add(r)}class T{constructor(e={}){this.cachedResponseWillBeUsed=async({event:t,request:s,cacheName:n,cachedResponse:a})=>{if(!a)return null;const i=this._isResponseDateFresh(a),o=this._getCacheExpiration(n);X(o.expireEntries());const c=o.updateTimestamp(s.url);if(t)try{t.waitUntil(c)}catch{}return i?a:null},this.cacheDidUpdate=async({cacheName:t,request:s})=>{const n=this._getCacheExpiration(t);await n.updateTimestamp(s.url),await n.expireEntries()},this._config=e,this._maxAgeSeconds=e.maxAgeSeconds,this._cacheExpirations=new Map,e.purgeOnQuotaError&&Qe(()=>this.deleteCacheAndMetadata())}_getCacheExpiration(e){if(e===k.getRuntimeName())throw new h("expire-custom-caches-only");let t=this._cacheExpirations.get(e);return t||(t=new Ve(e,this._config),this._cacheExpirations.set(e,t)),t}_isResponseDateFresh(e){if(!this._maxAgeSeconds)return!0;const t=this._getDateHeaderTimestamp(e);if(t===null)return!0;const s=Date.now();return t>=s-this._maxAgeSeconds*1e3}_getDateHeaderTimestamp(e){if(!e.headers.has("date"))return null;const t=e.headers.get("date"),n=new Date(t).getTime();return isNaN(n)?null:n}async deleteCacheAndMetadata(){for(const[e,t]of this._cacheExpirations)await self.caches.delete(e),await t.delete();this._cacheExpirations=new Map}}const bt={strategyStart:(r,e)=>`Using ${r} to respond to '${V(e.url)}'`,printFinalResponse:r=>{r&&(O.groupCollapsed("View the final response here."),O.log(r||"[No response returned]"),O.groupEnd())}};class Rt extends null{async _handle(e,t){const s=[];let n=await t.cacheMatch(e),a;if(!n)try{n=await t.fetchAndCachePut(e)}catch(i){i instanceof Error&&(a=i)}if(!n)throw new WorkboxError("no-response",{url:e.url,error:a});return n}}class Ct extends null{async _handle(e,t){const s=await t.cacheMatch(e);if(!s)throw new WorkboxError("no-response",{url:e.url});return s}}const ne={cacheWillUpdate:async({response:r})=>r.status===200||r.status===0?r:null};class B extends S{constructor(e={}){super(e),this.plugins.some(t=>"cacheWillUpdate"in t)||this.plugins.unshift(ne),this._networkTimeoutSeconds=e.networkTimeoutSeconds||0}async _handle(e,t){const s=[],n=[];let a;if(this._networkTimeoutSeconds){const{id:c,promise:l}=this._getTimeoutPromise({request:e,logs:s,handler:t});a=c,n.push(l)}const i=this._getNetworkPromise({timeoutId:a,request:e,logs:s,handler:t});n.push(i);const o=await t.waitUntil((async()=>await t.waitUntil(Promise.race(n))||await i)());if(!o)throw new h("no-response",{url:e.url});return o}_getTimeoutPromise({request:e,logs:t,handler:s}){let n;return{promise:new Promise(i=>{n=setTimeout(async()=>{i(await s.cacheMatch(e))},this._networkTimeoutSeconds*1e3)}),id:n}}async _getNetworkPromise({timeoutId:e,request:t,logs:s,handler:n}){let a,i;try{i=await n.fetchAndCachePut(t)}catch(o){o instanceof Error&&(a=o)}return e&&clearTimeout(e),(a||!i)&&(i=await n.cacheMatch(t)),i}}class xt extends null{constructor(e={}){super(e),this._networkTimeoutSeconds=e.networkTimeoutSeconds||0}async _handle(e,t){let s,n;try{const a=[t.fetch(e)];if(this._networkTimeoutSeconds){const i=timeout(this._networkTimeoutSeconds*1e3);a.push(i)}if(n=await Promise.race(a),!n)throw new Error(`Timed out the network response after ${this._networkTimeoutSeconds} seconds.`)}catch(a){a instanceof Error&&(s=a)}if(!n)throw new WorkboxError("no-response",{url:e.url,error:s});return n}}class v extends S{constructor(e={}){super(e),this.plugins.some(t=>"cacheWillUpdate"in t)||this.plugins.unshift(ne)}async _handle(e,t){const s=[],n=t.fetchAndCachePut(e).catch(()=>{});t.waitUntil(n);let a=await t.cacheMatch(e),i;if(!a)try{a=await n}catch(o){o instanceof Error&&(i=o)}if(!a)throw new h("no-response",{url:e.url,error:i});return a}}De([{'revision':'1f5ef1fed793977a3e4dc8de2b07f1d0','url':'/assets/css/base.css'},{'revision':null,'url':'/assets/js/505.js?_t=4b13a5dc50f7ffcd561e'},{'revision':null,'url':'/assets/js/account-navigation.js?_t=11da92008fd5ff1a29c3'},{'revision':null,'url':'/assets/js/analytics-body.js?_t=c4ed3bb7ee2fc04a8d4e'},{'revision':null,'url':'/assets/js/analytics-search.js?_t=5feaa2cf2cc955409248'},{'revision':null,'url':'/assets/js/bc-video-player-events.js?_t=3e7f56e62e7f462c3599'},{'revision':null,'url':'/assets/js/bc-video-player-overlay.js?_t=cfc774ebfcdb65416484'},{'revision':null,'url':'/assets/js/bc-video-playlist.js?_t=b9ae94a0c0a97f336d76'},{'revision':null,'url':'/assets/js/calendar-datesorter.js?_t=7ebe980738ac7c79b806'},{'revision':null,'url':'/assets/js/client-date.js?_t=5c2e4887b6cad6a0533d'},{'revision':null,'url':'/assets/js/google-adv.js?_t=f716198ec45bb772833d'},{'revision':null,'url':'/assets/js/header-navigation.js?_t=7bdac808f152093ec472'},{'revision':null,'url':'/assets/js/hero-text-color.js?_t=50aca1e394383a804075'},{'revision':'64ebcb2409570ceb660a4407eebface4','url':'/assets/js/main-template.js'},{'revision':'083c74d5dd4843ecf7d692f4808aac87','url':'/assets/js/main.js'},{'revision':null,'url':'/assets/js/modal.js?_t=50c8d4bc1c9e36f387dd'},{'revision':null,'url':'/assets/js/notification.js?_t=bb14a1920916a4623ce7'},{'revision':null,'url':'/assets/js/pattern-title.js?_t=2c59b0a7f59f9e662c69'},{'revision':null,'url':'/assets/js/sharebar.js?_t=05b3cbd336c3c4775857'},{'revision':null,'url':'/assets/js/switch-lang-modal.js?_t=163c3cea589edd8fe039'},{'revision':null,'url':'/assets/js/toggle-container.js?_t=b168a91af2ae90ca7fea'},{'revision':null,'url':'/assets/js/uniform-width.js?_t=7459f1ac0d4e79020575'}]),w(/https:\/\/media\.d3\.nhle\.com/,new v({cacheName:"cloudinary-cache",plugins:[new T({maxEntries:50,purgeOnQuotaError:!0})]})),w(/\/news\//,new B({cacheName:"news-cache",plugins:[new T({maxEntries:20,purgeOnQuotaError:!0})]})),w(/\/photos\//,new B({cacheName:"photos-cache",plugins:[new T({maxEntries:10,purgeOnQuotaError:!0})]})),w(/\/addon\//,new B({cacheName:"addon-cache"})),w(/\.(?:woff|woff2)$/,new v({cacheName:"fonts-cache",plugins:[new T({maxAgeSeconds:60*60*24*365})]})),w(/\.(?:png|jpg|jpeg|svg,gif,ico)$/,new v({cacheName:"images-cache",plugins:[new T({maxEntries:20,purgeOnQuotaError:!0})]})),w(/\/assets\//,new v({maxAgeSeconds:60*60*24*365,cacheName:"assets-cache"}))})()})();
